<html>
<head>
	<title>HYPY </title>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
	<link rel="shortcut icon" href="#" />
	<link rel="manifest" href="manifest.json">
	<meta name="mobile-web-app-capable" content="yes">
	<link rel="stylesheet" href="style.css">
</head>

<body bgcolor="white" onload=onload()>
	<audio id="player"></audio>
	<video id="gum-local" autoplay playsinline hidden></video>
	<table align="center">
		<tr>
			<td id="mainTable">
				<canvas id="myCanvas2"></canvas>
			</td>
		</tr>
	</table>
</body>

<script async src="js/artoolkit.min.js"></script>
<script async src="js/three.min.js"></script>
<script async src="js/artoolkit.three.js"></script>
<script src="https://code.createjs.com/easeljs-0.8.2.min.js"></script>
<script src="https://code.createjs.com/tweenjs-0.6.2.min.js"></script>

<script>

window.ARThreeOnLoad = function() {

	var scaleAnchorX = 1;
	var scaleAnchorY = 1;

	var prevSoundName = "";
	var soundName = "";

	// in canvas ratio
	var soundIconPosX = 0.5;
	var soundIconPosY = 0.8 + 0.06;
	var soundIconLength = 0.05;
	var soundIconActive = false;

	var toneID = -1;
	var yunmuID = -1;
	var shengmuID = -1;

	var tonePosCheckHistory = [];
	var validCheckHistory = [];
	var ysSpaceCheckHistory = [];

	var bufferSize = 120;
	var debugMode = false;

	var errorCode = -1;

	var yunmuSlot = [];
	var shengmuSlot = [];
	var toneSlot = [];

	var validCombi = [];

	var markerTracked = {};
	var history = [];

	var imageDir = "images/";

	const validButNoTone = ["an2", "ang3", 
						  "bang2", "ben2", "bian2", "biao2", "bin2", "bin3", "bing2",
						  "ca2", "ca4", "cang3", "cang4", "ce1", "ce2", "ce3",  "cei1", "cei2", "cei3", 
						  "cen3", "cen4", "ceng3", "che2", "chua2", "chua3", "chua4", "chui3", "chui4", "chun4", 
						  "chuo2", "chuo3", "cong3", "cong4", "cou1", "cou2", "cou3", "cu3", "cuan3", "cui2",
						  "dai2", "dan2", "dang2", "de3", "dei2", "dei4", "den1", "den2", "den3", "deng2", 
						  "dia1",  "dia2",  "dia4", "dian2", "diao2", "die3", "die4", "ding2",
						  "diu2", "diu3", "diu4", "dong2", "dou2", "duan2", "dui2", "dui3", "dun2", 
						  "en2", "en3", "eng2",  "eng3",  "eng4",  "er1", 
						  "fo1", "fo3", "fo4", "fou1", "fou2", "fou4", 
						  "gai2", "gan2", "gang2", "gao2", "gei1", "gei2", "gei4", "geng2", "gong2", "gou2", 
						  "gu2", "gua2", "guai2", "guan2", "guang2", "gui2", "gui4", "ga1", 
						  "ga2", "ga3", "gai2", "gan2", "gang2", "gao2", "gei1",  "gei2",  "gei4", "geng2", 
						  "gong2", "gou2", "gu2", "gua2", "guai2", "guan2", "guang2", "gui2", "gun1", "gun2",
						  "hang3", "he3", "hei2", "hei3", "hei4", "hen1", "heng3", "hua3", "huai1", "huai3", "hun3", "jian2", "jiang2",
						  "jin2", "jing2", "jiong2", "jiong4", "jiu2", "juan2", "jun2", "jun3",
						  "ka2", "ka4", "kai2", "kan2", "kang3",
						  "zhuang2"];
	
	const yunmu = [
		"ai", "an", "ang", "ao", "a", 
		"e", "ei", "en", "eng", "er", 
		"i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", 
		"o", "ong", "ou", 
		"u", "ua", "uai", "uan", "uang", "ue", "ui", "un", "uo", 
		"v", "ve",
		"g"
	];

	const shengmu = [
		"", "b", "c", "ch", "d", "f", "g", "h", "j", "k", "l", "m", 
		"n", "p", "q", "r", "s", "sh", "t", "w", "x", "y", "z", "zh"
	];

	const markerMapping = ["tone1", "tone2", "tone3", "tone4",
						"iang", "iong", "uang",
						"ang", "eng", "ong", "uai", "uan", 
						"ian", "iao", "ing", 
						"ia", "ie", "in", "ai", "an", 
						"ao", "ei", "en", "er", "iu",
						"ou", "ua", "ue", "ui", "un", 
						"uo", "ve",  
						"a", "e", "i", "o", "u", "v", "g", // 39
						"b", "c", "ch", "d", "f", "g", "h", "j", "k", "l",
						"m", "n", "p", "q", "r", "s", "sh", "t", "w", "x",
						"y", "z", "zh"];

	const toneMarkerTarget = [-1, -1, -1, -1, 
						66.4, 66.1, 55.5,//55.5,
						77.6, 78.2, 78.2, 55.5, 55.5, 
						65.6, 65.5, 83.1, 
						66.4, 66.1, 83.1, 77.6, 77.6, 
						77.6, 78.2, 78.2, 78.2, 66.2,
						78.2, 55.5, 56.1, 61.1, 78.2, 
						56.1, 57.8, 
						77.6, 78.2, 83.1, 78.2, 78.2, 78.9, 78.6];
	const yunmuVowelOnSecond = ["ia", "ie", "iu", "ua", 
								"ue", "ui", "uo", "ve", "uai", 
								"iao", "iong", "uan", "uang",
								"ian", "iang"];

	const DisplayStates = {
		Invalid: -1, // do nothing
		Neutral: 0, // wait, show black text
		Correct1: 1, // correct combi
		Correct2: 2, // correct!
		ErrorCombi: 3, // wrong Y S combi
		ErrorNoTone: 4, // no such tone for combi
		ErrorTonePos: 5, // tone is existent but in wrong position
		ErrorSwapped: 6, // Y and S position are swapped
		ErrorTooFar: 7, // Y and S are too far apart
		ErrorTooNear: 8 // Y and S are too close
	};

	var displayState = DisplayStates.Neutral;
	var displayText = "";

	function sizeCanvas(canvas, winWidth, winHeight) {
		//console.log(winWidth + " " + winHeight);
		if ((winWidth / 640 * 480) > winHeight) {
			
			var finalHeight = winHeight;
			var finalWidth = winHeight / 480 * 640;
			scaleAnchorY = winHeight / 480;
			scaleAnchorX = finalWidth / 640;
			console.log("clamp height "+finalWidth + " " + finalHeight);
			canvas.style.height = finalHeight;
			canvas.style.width = finalWidth;
		} else {
			var finalWidth = winWidth;
			var finalHeight = winWidth / 640 * 480;
			scaleAnchorX = winWidth / 640;
			scaleAnchorY = finalHeight / 480;

			canvas.style.width = finalWidth;
			canvas.style.height = finalHeight;
		}
	}

	function drawSoundIcon(ctx, cw, ch, active) {
		var img1=document.getElementById("sound1");
		var img2=document.getElementById("sound2");
		var img = active ? img2 : img1;
		ctx.drawImage(img, 
			cw * (soundIconPosX - soundIconLength*0.5), 
			ch * (soundIconPosY - soundIconLength*0.5), 
			cw*soundIconLength, 
			cw*((soundIconLength / 70) * 53));
	}

	function drawCenterLine(ctx, cw, ch) {
		ctx.strokeStyle = 'DimGrey';
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.moveTo(cw * 0.3, ch * 0.7);
		ctx.lineTo(cw * 0.7, ch * 0.7);
		ctx.stroke();
	}

	function drawCenterText(ctx, cw, ch, color, text) {
		if (text === "") return;
		//ctx.fillStyle = "#ff0000";
		ctx.fillStyle = color;
		var fontSize = 75 * scaleAnchorX
		ctx.font = fontSize+"px Hypy";
		var setA = "ABCDE";
		var setB = "FGHIJ";
		var setC = "KLMNO";
		var setD = "PQRST";
		var setE = "UVWXY";
		var setF = "Z_^`~|";

		var textWidth = ctx.measureText(text).width;
		console.log();
		ctx.fillText(text, cw * 0.5 - textWidth * 0.5, ch * 0.7);
		//console.log(text);		
		//ctx.fillText("\u00E0", cw * 0.55, ch * 0.7);
	}
	
	function drawMarkerOutline(ctx, vertex, pos, id) {
		//if (id==-1) id = 99;
		//if (id2==-1) id2 = 99;
		//console.log(scaleX + " " + scaleY + " " + scaleAnchorX);
		if (id === -1) return;
		ctx.strokeStyle = 'red';
		ctx.lineWidth = 1 * scaleAnchorX;
		ctx.beginPath();
		ctx.moveTo(vertex[0][0]*scaleAnchorX, vertex[0][1]*scaleAnchorY);
		ctx.lineTo(vertex[1][0]*scaleAnchorX, vertex[1][1]*scaleAnchorY);
		ctx.stroke();

		ctx.strokeStyle = 'blue';
		ctx.beginPath();
		ctx.lineTo(vertex[1][0]*scaleAnchorX, vertex[1][1]*scaleAnchorY);
		ctx.lineTo(vertex[2][0]*scaleAnchorX, vertex[2][1]*scaleAnchorY);
		ctx.stroke();
		ctx.strokeStyle = 'green';

		ctx.beginPath();
		ctx.moveTo(vertex[2][0]*scaleAnchorX, vertex[2][1]*scaleAnchorY);
		ctx.lineTo(vertex[3][0]*scaleAnchorX, vertex[3][1]*scaleAnchorY);
		ctx.stroke();

		ctx.strokeStyle = 'yellow';
		ctx.beginPath();
		ctx.moveTo(vertex[3][0]*scaleAnchorX, vertex[3][1]*scaleAnchorY);
		ctx.lineTo(vertex[0][0]*scaleAnchorX, vertex[0][1]*scaleAnchorY);
		ctx.stroke();

		// print marker id
		if (true) {
			ctx.beginPath();
			ctx.arc(pos[0]*scaleAnchorX, pos[1]*scaleAnchorY, 8, 0, Math.PI * 2);
			ctx.fillStyle = "#00ff00";
			ctx.fill();

			var fontSize = 25 * scaleAnchorX;
			ctx.font = fontSize + "px Arial";
			ctx.fillText(id,pos[0]*scaleAnchorX,pos[1]*scaleAnchorY);
		}				
	}

	// combi error
	// 声韵母组合错误，请跟换卡片。
	// \u58f0\u97f5\u6bcd\u7ec4\u5408\u9519\u8bef\uFF0C\u8bf7\u8ddf\u6362\u5361\u7247\u3002
	// wrong tone position
	// 音调卡位置错误，请跟换卡片。
	// \u97f3\u8c03\u5361\u4f4d\u7f6e\u9519\u8bef\uFF0C\u8bf7\u8ddf\u6362\u5361\u7247\u3002
	// no corresponding tone for combi
	// 音调不符合拼音，请跟换卡片。
	// \u97f3\u8c03\u4e0d\u7b26\u5408\u62fc\u97f3\uFF0C\u8bf7\u8ddf\u6362\u5361\u7247\u3002
	// yunmu shengmu swapped
	// 声韵母位置错误，请跟换位置。
	// \u58f0\u97f5\u6bcd\u4f4d\u7f6e\u9519\u8bef\uFF0C\u8bf7\u8ddf\u6362\u4f4d\u7f6e\u3002
	//correct1 恭喜你，你答对了！
	//correct0 声韵母组合对了，请放音调卡。

	function printError(ctx, cw, ch, state) {

		drawCenterLine(ctx, cw, ch);
		//drawSoundIcon(ctx, cw, ch, false);
		soundIconActive = false;

		var fontSize = 20 * scaleAnchorX
		ctx.font = fontSize+"px kaiti";

		//var rect = ctx.canvas.getBoundingClientRect();
		var textWidth = ctx.measureText("\u58f0\u97f5\u6bcd\u7ec4\u5408\u9519\u8bef\uFF0C\u8bf7\u66f4\u6362\u5361\u7247\u3002").width;
		//console.log(rect.width + " " + rect.height);
		var svg = null;
		
		ctx.fillStyle = 'red';
		var centerTextColor = 'black';


		// if (state == DisplayStates.ErrorCombi) { // combi error
		// 	ctx.fillText("\u58f0\u97f5\u6bcd\u7ec4\u5408\u9519\u8bef\uFF0C\u8bf7\u66f4\u6362\u5361\u7247\u3002", cw * 0.5 - textWidth * 0.5, ch * 0.45); 
		// 	svg = document.getElementById("error0");
		// 	centerTextColor = 'red';
		// }
		// else if (state == DisplayStates.ErrorTonePos) { // wrong tone position
		// 	ctx.fillText("\u97f3\u8c03\u5361\u4f4d\u7f6e\u9519\u8bef\uFF0C\u8bf7\u66f4\u6362\u5361\u7247\u3002", cw * 0.5 - textWidth * 0.5, ch * 0.45);
		// 	svg = document.getElementById("error1");
		// 	//ctx.drawImage(svg, 0, 0, 200, 100);
		// 	centerTextColor = 'red';
		// }
		// else if (state == DisplayStates.ErrorNoTone) {// no corresponding tone for combi
		// 	ctx.fillText("\u97f3\u8c03\u4e0d\u7b26\u5408\u62fc\u97f3\uFF0C\u8bf7\u66f4\u6362\u5361\u7247\u3002", cw * 0.5 - textWidth * 0.5, ch * 0.45);
		// 	svg = document.getElementById("error2");
		// 	//ctx.drawImage(svg, 0, 0, 200, 100);
		// 	centerTextColor = 'red';
		// }
		// else if (state == DisplayStates.ErrorSwapped) { // yunmu shengmu swapped
		// 	ctx.fillText("\u58f0\u97f5\u6bcd\u4f4d\u7f6e\u9519\u8bef\uFF0C\u8bf7\u66f4\u6362\u4f4d\u7f6e\u3002", cw * 0.5 - textWidth * 0.5, ch * 0.45);
		// 	svg = document.getElementById("error3");
		// 	//ctx.drawImage(svg, 0, 0, 200, 100);
		// 	centerTextColor = 'red';
		// }else if (state == DisplayStates.Neutral) {
		// 	centerTextColor = 'black';
		// }
		// else if (state == DisplayStates.Correct1) {
		// 	ctx.fillStyle = 'green';
		// 	var textWidth = ctx.measureText("\u58f0\u97f5\u6bcd\u7ec4\u5408\u5BF9\u4E86\uFF0C\u8bf7\u653E\u97f3\u8c03\u5361\u3002").width;
		// 	ctx.fillText("\u58f0\u97f5\u6bcd\u7ec4\u5408\u5BF9\u4E86\uFF0C\u8bf7\u653E\u97f3\u8c03\u5361\u3002", cw * 0.5 - textWidth * 0.5, ch * 0.45);
		// 	svg = document.getElementById("correct0");
		// 	centerTextColor = 'green';
		// } else if (state == DisplayStates.Correct2) {
		// 	ctx.fillStyle = 'green';
		// 	var textWidth = ctx.measureText("\u606D\u559C\u4F60\uFF0C\u4F60\u7B54\u5BF9\u4E86\uFF01").width;
		// 	ctx.fillText("\u606D\u559C\u4F60\uFF0C\u4F60\u7B54\u5BF9\u4E86\uFF01", cw * 0.5 - textWidth * 0.5, ch * 0.45); 
		// 	svg = document.getElementById("correct1");
		// 	centerTextColor = 'green';
		// }

		drawCenterText(ctx, cw, ch, centerTextColor, displayText);

		// if (state != DisplayStates.Invalid && state != DisplayStates.Neutral) {
		// 	//console.log(state);
		// 	var bBox = svg.getBBox();
		// 	var egWidth = bBox.width;
		// 	var egHeight = bBox.height;

		// 	//var widthRatio = (egWidth / cw) * 2.5;
		// 	var widthRatio = 0.4;
		// 	var heightRatio = (widthRatio / egWidth) * egHeight;

		// 	ctx.drawImage(svg, (cw * 0.5) - (cw * widthRatio * 0.5), (ch * 0.18) - (cw * heightRatio * 0.5), cw * widthRatio, cw * heightRatio);	
		// 	//errorCode = -1;
		// }

		displayState = DisplayStates.Invalid;
	}

	function playSound(soundName) {

		var player = document.getElementById("player");
		//player.innerHTML = "<source src='sounds/" + soundName + ".mp3' type='audio/mpeg'>";
		player.innerHTML = "<source src='https://yabla.vo.llnwd.net/media.yabla.com/chinese_static/audio/alicia/" + soundName + ".mp3' type='audio/mpeg'>";
		
		player.load();
		var playPromise = player.play();
		if (playPromise !== undefined) {
		    playPromise.then(_ => {
		      // Automatic playback started!
		      // Show playing UI.
		      // We can now safely pause video...
		      //console.log("success play?");
		      video.pause();
		    })
		    .catch(error => {
		      // Auto-play was prevented
		      // Show paused UI.
		      //console.log("fail play..."+error);
		    });
		}
	}

	ARController.getUserMediaThreeScene({
		maxARVideoSize: 640,
		cameraParam: 'data/camera.dat',
		onSuccess: function(arScene, arController, arCamera) {

			var renderer = new THREE.WebGLRenderer({antialias: true});

			arSetup(arController, renderer);
			var rendererCanvas = renderer.domElement;

			sizeCanvas(rendererCanvas, window.innerWidth, window.innerHeight);
			
			var overlay = document.getElementById("myCanvas2");
			overlay.style.width = rendererCanvas.style.width;
			overlay.style.height = rendererCanvas.style.height;
			var ctx = overlay.getContext('2d');
			
			const width = rendererCanvas.clientWidth;
			const height = rendererCanvas.clientHeight; 

			overlay.width = width;
			overlay.height = height;

			var canvasWidth = width;
			var canvasHeight = height;

			// clicking of canvas
			overlay.onclick = function(e) {
				var rect = overlay.getBoundingClientRect();
				var canvasX = e.clientX - rect.left;
				var canvasY = e.clientY - rect.top;

				var soundIconTrueX = rect.width * soundIconPosX;
				var soundIconTrueY = rect.height * soundIconPosY;

				var diffX = Math.abs(soundIconTrueX - canvasX);
				var diffY = Math.abs(soundIconTrueY - canvasY);
				var thresh = rect.width * soundIconLength * 0.5;
				if (diffX < thresh && diffY < thresh) {
					if (soundName === "") return;
					playSound(soundName);
				}
			};

			sceneSetup(arScene);
			mappingFunction();
			tick(ctx);

			easelSetup();

			var marker0;
			var obj3d;
			
			function arSetup(arController, renderer) {
				document.body.className = arController.orientation;
				arController.setPatternDetectionMode(artoolkit.AR_MATRIX_CODE_DETECTION);

				arController.borderStyle = "white";
				
				// setting renderer size
				if (arController.orientation === 'portrait') {
					var w = (window.innerWidth / arController.videoHeight) * arController.videoWidth;
					var h = window.innerWidth;
					renderer.setSize(w, h);
					renderer.domElement.style.paddingBottom = (w-h) + 'px';
				} else {
					if (/Android|mobile|iPad|iPhone/i.test(navigator.userAgent)) {
						renderer.setSize(window.innerWidth, (window.innerWidth / arController.videoWidth) * arController.videoHeight);
					} else {
						renderer.setSize(arController.videoWidth, arController.videoHeight);
						document.body.className += ' desktop';
					}
				}
				
				// add three js renderer to main_table
				var mainTable = document.getElementById("mainTable");
				mainTable.appendChild(renderer.domElement, mainTable);
			}
			
			function sceneSetup(arScene) {

				var sphere = new THREE.Mesh(
					new THREE.SphereGeometry(0.5, 10, 10),
					new THREE.MeshNormalMaterial()
				);
				sphere.material.shading = THREE.FlatShading;
				sphere.position.z = 1.0;

				var torus = new THREE.Mesh(
					new THREE.TorusGeometry(0.1*2.5, 0.2*2.0, 10, 10),
					new THREE.MeshNormalMaterial()
				);
				torus.material.shading = THREE.FlatShading;
				torus.position.z = 1.25;
				torus.rotation.x = Math.PI/2;
				
				var cube = new THREE.Mesh(
					new THREE.BoxGeometry(1,1,1),
					new THREE.MeshNormalMaterial()
				);
				cube.material.shading = THREE.FlatShading;
				cube.position.z = 0.5;

				for(var i=0; i<62; i++) {
					var markerRoot = arController.createThreeBarcodeMarker(i);
					markerRoot.markerID = i;
					arScene.scene.add(markerRoot);
				}
			}

			function svgScaling(bitmap, canvas, scale) {
	    		let bounds = bitmap.getBounds();
	            if (bounds === null) {
	            	console.log("svg scaling exited: bounds null");
	            	setTimeout(function() {svgScaling(bitmap, canvas);}, 1000);
	            	return;
	            };
	    		if (bounds.width > bounds.height) {
					bitmap.scaleX = bounds.width/canvas.width;
					bitmap.scaleY = bounds.width/canvas.width;
				} else {
					bitmap.scaleX = bounds.height/canvas.height;
					bitmap.scaleY = bounds.height/canvas.height;
				}

				if (typeof scale !== "undefined") {
					bitmap.scaleX *= scale;
					bitmap.scaleY *= scale;
				}
	    	}

	    	function bitmapErrorSetup1b(stage) {
	    		let scale = 0.6;
	    		
	    		let container = new createjs.Container();
	    		let bitmap = new createjs.Bitmap(imageDir+"wrong_big.png");

	    		createjs.Ticker.addEventListener("tick", function(event) {
	    			if (displayState === DisplayStates.ErrorCombi) {
						container.visible = true;
						var yunText = markerMapping[yunmuID];
						var shengText = markerMapping[shengmuID];
						sheng.text = shengText;
	    				yun.text = yunText;
						setPos();
					} else {
						container.visible = false;
					}
					stage.update(event);
				});
				container.addChild(bitmap);
				stage.addChild(container);
				stage.update();
	    		
	    		let bWidth = 1000;

				let scale3 = ( stage.canvas.width * scale ) / bWidth;

				container.scaleX = scale3;
				container.scaleY = scale3;

				container.x = stage.canvas.width * 0.5;
				container.y = stage.canvas.height * 0.3;

	    		let scaleFontSize = 60 * scaleAnchorX / scale3;
	    		let sheng = new createjs.Text("ch", scaleFontSize + "px Hypy", "#000000"); //人\u97f3
				sheng.textBaseline = "alphabetic";

				let yun = new createjs.Text("eng", scaleFontSize + "px Hypy", "#000000"); //人\u97f3
				yun.textBaseline = "alphabetic";

				container.addChild(sheng, yun);

				var winWidth = window.innerWidth
					|| document.documentElement.clientWidth
					|| document.body.clientWidth;

				var leftOffset = stage.canvas.getBoundingClientRect().left;
				var canvasWidth = stage.canvas.width;

				function setPos() {
					bitmap.x = -bWidth * 0.5 ;
					bitmap.y = 0;

					sheng.y = -stage.canvas.height * 0.00 + sheng.getMeasuredHeight() * 1.2;
					yun.y = -stage.canvas.height * 0.00 + sheng.getMeasuredHeight() * 1.2;

					sheng.x = bWidth * -0.25  - sheng.getMeasuredWidth() * 0.5;
					yun.x = bWidth * 0.03;	
				}
				setPos();
	    	}

	    	function bitmapErrorSetup2b(stage) {
	    		let scale = 0.47;
	    		let scale2 = 0.2;
	    		let container = new createjs.Container();
	    		let container2 = new createjs.Container();

	    		//if (yunmuID == -1 || shengText == -1) return;

	    		var yunText = markerMapping[yunmuID];
				var shengText = markerMapping[shengmuID];

	    		let bitmap = new createjs.Bitmap(imageDir+"correct_big.png");
	    		let bitmap2 = new createjs.Bitmap(imageDir+"tone_top1.png");
	    		let bitmap3 = new createjs.Bitmap(imageDir+"tone_top2.png");
	    		let bitmap4 = new createjs.Bitmap(imageDir+"tone_top3.png");
	    		let bitmap5 = new createjs.Bitmap(imageDir+"tone_top4.png");

	    		let tones = [bitmap2, bitmap3, bitmap4, bitmap5];

	    		let rawCardWidth = 1000;

	    		let toneCardHeight = 1000;
	    		let toneCardWidth = 708;

				let scale3 = ( stage.canvas.width * scale ) / rawCardWidth;
				let scale4 = ( stage.canvas.height * scale2 ) / toneCardHeight;
				

	    		let fontSize = 60 * scaleAnchorX / scale3;
	    		let sheng = new createjs.Text("ch", fontSize+"px Hypy", "#000000"); //人\u97f3
				sheng.textBaseline = "alphabetic";

				let yun = new createjs.Text("eng", fontSize+"px Hypy", "#000000"); //人\u97f3
				yun.textBaseline = "alphabetic";

				container.addChild(bitmap);
				container.addChild(sheng, yun);
				container2.addChild(bitmap2, bitmap3, bitmap4, bitmap5);

				container.scaleX = scale3;
				container.scaleY = scale3;

				container2.scaleX = scale4;
				container2.scaleY = scale4;

				stage.addChild(container, container2);
				stage.update();

	    		createjs.Ticker.addEventListener("tick", function(event) {

	    	 		if (displayState === DisplayStates.ErrorTonePos) {
	    	 			container.visible = true;
	    	 			bitmap.visible = true;
	    	 			tones.forEach(function(e) {
	    	 				e.visible = false;
	    	 			});

	    	 			if (toneID === -1) return;
	    	 			tones[toneID].visible = true;

	    	 			yunText = markerMapping[yunmuID];
						shengText = markerMapping[shengmuID];
						sheng.text = shengText;
	    	 			yun.text = yunText;
						 setPos();
	    	 		} else {
	    	 			container.visible = false;
	    	 			bitmap.visible = false;
	    	 			tones.forEach(function(e) {
	    	 				e.visible = false;
	    	 			});
	    	 		}
	    			
					stage.update(event);
				});
            	
				//svgScaling(bitmap, stage.canvas);
				//svgScaling(bitmap2, stage.canvas);
				tones.forEach(function(e) {
	 				//svgScaling(e, stage.canvas, scale2);
	 			});

				container.x = stage.canvas.width * 0.5;
	    		container.y = stage.canvas.height * 0.3;
	    		container2.x = stage.canvas.width * 0.5;
	    		container2.y = stage.canvas.height * 0.1;
	    		//container.y = stage.canvas.height * 0.5;

				//container.scaleX *= scale;
				//container.scaleY *= scale;

				//container.scaleX *= scale;
				//container.scaleY *= scale;

				//console.log(bitmap.scaleX);

				var tween1 = null;
				var tween2 = null;
				var tween3 = null;
				var tween4 = null;

				function setPos() {

					bitmap.x = -rawCardWidth * 0.5;
					bitmap.y = stage.canvas.height * 0.0;

					
		 			sheng.y = sheng.getMeasuredHeight() * 1.2;
		 			yun.y = yun.getMeasuredHeight() * 1.2;

		 			sheng.x = -rawCardWidth * 0.12 - sheng.getMeasuredWidth() ;
		 			yun.x = -0.12 * rawCardWidth;

		 			let cardWidth = stage.canvas.width * scale / scale4;
		 			//let toneWidth = stage.canvas.width * scale2 / scale4; // tone marker is 708 x 1000 dimension\
		 			let toneWidth = scale2 / toneCardHeight * toneCardWidth * stage.canvas.height / scale4;

		 			tones.forEach(function(e) {
						e.x = cardWidth * 0.12;
		 			});
				
					if (tween1 === null) {
						tween1 = createjs.Tween.get(bitmap2, { loop: true })
						  .to({ x: cardWidth * -0.12 - toneWidth}, 2000, createjs.Ease.getPowInOut(2))
						  .to({ x: cardWidth * -0.12 - toneWidth}, 200)
						  .to({ x: cardWidth * 0.12 }, 2000, createjs.Ease.getPowInOut(2))
						  .to({ x: cardWidth * 0.12 }, 200);
					}
					if (tween2 === null) {
						tween2 = createjs.Tween.get(bitmap3, { loop: true })
						  .to({ x: cardWidth * -0.12 - toneWidth}, 2000, createjs.Ease.getPowInOut(2))
						  .to({ x: cardWidth * -0.12 - toneWidth}, 200)
						  .to({ x: cardWidth * 0.12 }, 2000, createjs.Ease.getPowInOut(2))
						  .to({ x: cardWidth * 0.12 }, 200);
					}
					if (tween3 === null) {
						tween3 = createjs.Tween.get(bitmap4, { loop: true })
						  .to({ x: cardWidth * -0.12 - toneWidth}, 2000, createjs.Ease.getPowInOut(2))
						  .to({ x: cardWidth * -0.12 - toneWidth}, 200)
						  .to({ x: cardWidth * 0.12 }, 2000, createjs.Ease.getPowInOut(2))
						  .to({ x: cardWidth * 0.12 }, 200);
					}
					if (tween4 === null) {
						tween4 = createjs.Tween.get(bitmap5, { loop: true })
						  .to({ x: cardWidth * -0.12 - toneWidth}, 2000, createjs.Ease.getPowInOut(2))
						  .to({ x: cardWidth * -0.12 - toneWidth}, 200)
						  .to({ x: cardWidth * 0.12 }, 2000, createjs.Ease.getPowInOut(2))
						  .to({ x: cardWidth * 0.12 }, 200);
					}
				}

    			setPos();
				stage.update();
	    	}

	    	function bitmapErrorSetup3b(stage) {

	    		let scale = 0.46;

	    		let container = new createjs.Container();

	    		var bitmap1 = new createjs.Bitmap(imageDir+"tone_wrong1.png");
	    		var bitmap2 = new createjs.Bitmap(imageDir+"tone_wrong2.png");
	    		var bitmap3 = new createjs.Bitmap(imageDir+"tone_wrong3.png");
	    		var bitmap4 = new createjs.Bitmap(imageDir+"tone_wrong4.png");
	    		
	    		let choices = [bitmap1, bitmap2, bitmap3, bitmap4];
	    		let canvasMid = stage.canvas.width * 0.5;

	    		choices.forEach(function(e) {
	    			container.addChild(e);
	    			e.visible = false;
	    			//svgScaling(e, stage.canvas, scale);
	    		});

	    		let pngHeight = 1000;
	    		let scale2 = stage.canvas.height * 0.46 / pngHeight;

	    		container.scaleX = scale2;
	    		container.scaleY = scale2;

	    		stage.addChild(container);
	    		stage.update();


	    		let markerWidth = (stage.canvas.height * scale) / 1000 * 377;

	    		container.x = stage.canvas.width * 0.5 - markerWidth * 0.5;
	    		container.y = stage.canvas.height * 0.15

	    		function setPos() {
	    // 			if ( ! (choices.length > 0)) return;
					// let bounds = choices[0].getBounds();
	    			
					// if (bounds === null) {
					// 	setTimeout(function(){setPos();}, 1000);
					// 	return;
					// };
					// console.log(bounds);

					// 57 150 (bounds)
					

					choices.forEach(function(e) {
						//e.x = canvasMid;// - markerWidth * 0.5;
						//e.y = stage.canvas.height * 0.15;
	    			});

					choices.forEach(function(e) {
		    			e.visible = false;
		    		});

		    		createjs.Ticker.addEventListener("tick", function(event) {

		    			if (displayState === DisplayStates.ErrorNoTone) {
			    			if (toneID === -1 ) {
			    			 	return;
			    			}
			    			var bitmap = choices[toneID];
			    			choices.forEach(function(e) {
			    				e.visible = false;
			    			});
			    			bitmap.visible = true;
							
						} else {
							choices.forEach(function(e) {
			    				e.visible = false;
			    			});
						}
						stage.update(event);
					});

					//console.log("error 3 setpos done "+bitmap1.scaleX + " " + bitmap1.scaleY);
					stage.update();
	    		}

	    		setPos();
	    		stage.update();
	    	}

	    	function bitmapErrorSetup4b(stage) {
	    		//let scale = 0.23;
	    		let scale = 0.3;
	    		let container = new createjs.Container();
	    		let container2 = new createjs.Container();
	    		let bitmap = new createjs.Bitmap(imageDir+"blank.png");
	    		let bitmap2 = new createjs.Bitmap(imageDir+"blank.png");

	    		createjs.Ticker.addEventListener("tick", function(event) {
					
					if (displayState === DisplayStates.ErrorSwapped) {
						container.visible = true;
						container2.visible = true;
						var yunText = markerMapping[yunmuID];
						var shengText = markerMapping[shengmuID];
						sheng.text = shengText;
	    	 			yun.text = yunText;
						setPos();
					} else {
						container.visible = false;
						container2.visible = false;
					}
					stage.update(event);
				});

				container.addChild(bitmap);
				container2.addChild(bitmap2);
				stage.addChild(container, container2);
				//stage.addChild(bitmap3);
				stage.update();



	   		//container.scaleX = 1.68;// * scale;
	   			//container.scaleY = 1.68;// * scale;
	   			//container2.scaleX = 1.68;// * scale;
	   			//container2.scaleY = 1.68;// * scale;
	   			//bitmap3.scaleX = 1.5;
	   			//bitmap3.scaleY = 1.5;

	   			//let scale2 = 1.8 * scale;

	   			let bWidth = 1000;

				let scale3 = ( stage.canvas.width * scale ) / bWidth;

				container.scaleX = scale3;
				container.scaleY = scale3;
				container2.scaleX = scale3;
				container2.scaleY = scale3;

	    		const canvasMid = stage.canvas.width * 0.5
	    		//container.x = canvasMid;
	    		//container.y = stage.canvas.height * 0.3;
	    		//container2.x = canvasMid;
	    		//container2.y = stage.canvas.height * 0.3;

	    		let fontSize = 60 * scaleAnchorX / scale3;
	    		let sheng = new createjs.Text("ch", fontSize + "px Hypy", "#000000"); //人\u97f3
				sheng.textBaseline = "alphabetic";

				let yun = new createjs.Text("eng", fontSize + "px Hypy", "#000000"); //人\u97f3
				yun.textBaseline = "alphabetic";

				container.addChild(yun);
				container2.addChild(sheng);

				container.x = canvasMid;
				container.y = stage.canvas.height * 0.3;
				container2.x = canvasMid;
				container2.y = stage.canvas.height * 0.3;

	    		function setPos() {
	    			let bounds = bitmap.getBounds();
					if (bounds === null) {
						setTimeout(function() {setPos();}, 1000);
						return;
					}

					//bitmap.x = -stage.canvas.width * (1.1 / scale2);
					//bitmap2.x = stage.canvas.width * (0.1 / scale2);

					//bitmap.x = -stage.canvas.width * (1.1);
					//bitmap2.x = stage.canvas.width * (0.1);

					const bitmapStart2 = bWidth * 0.1;
					const bitmapStart1 = -bWidth * 1.1;
					bitmap2.x = bWidth * 0.1;
					bitmap.x = -bWidth * 1.1;

					 //bitmap.x = bounds.width * -1.05;
					// bitmap.y = bounds.height * 0.95;

					// bitmap2.x = bounds.width * 0.05;
					// bitmap2.y = bounds.height * 0.95;

					sheng.y = sheng.getMeasuredHeight() * 1.2;
					yun.y = yun.getMeasuredHeight()  * 1.2;

					//sheng.y = sheng.getMeasuredHeight() * (1.25 / 1.5);
					//yun.y = yun.getMeasuredHeight()  * (1.25 / 1.5);

					const shengStart = bWidth * 0.6 - sheng.getMeasuredWidth() * 0.5;
					const yunStart = -bWidth * 1.1;
					sheng.x = shengStart;
					yun.x = yunStart;

					 createjs.Tween.get(container, { loop: true })
					   .to({ x: canvasMid + stage.canvas.width * 1.2 * 0.3 }, 1000, createjs.Ease.getPowInOut(2))
					   .to({ x: canvasMid + stage.canvas.width * 1.2 * 0.3 }, 200)
					   .to({ x: canvasMid }, 1000, createjs.Ease.getPowInOut(2))
					   .to({ x: canvasMid }, 200);

					   createjs.Tween.get(container2, { loop: true })
					   .to({ x: canvasMid - stage.canvas.width * 1.2 * 0.3 }, 1000, createjs.Ease.getPowInOut(2))
					   .to({ x: canvasMid - stage.canvas.width * 1.2 * 0.3 }, 200)
					   .to({ x: canvasMid }, 1000, createjs.Ease.getPowInOut(2))
					   .to({ x: canvasMid }, 200);
	    		}
	    		setPos();
	    	}

	    	function bitmapErrorSetup5b(stage) {
	    		let scale = 0.3; //1.3

	    		let container = new createjs.Container();
	    		let container2 = new createjs.Container();
	    		let bitmap = new createjs.Bitmap(imageDir+"blank.png");
	    		let bitmap2 = new createjs.Bitmap(imageDir+"blank.png");

	    		createjs.Ticker.addEventListener("tick", function(event) {

	    			if (displayState === DisplayStates.ErrorTooNear) {
	    				container.visible = true;
	    				container2.visible = true;
	    				var yunText = markerMapping[yunmuID];
						var shengText = markerMapping[shengmuID];
						//console.log(yunText);
						sheng.text = shengText;
	    	 			yun.text = yunText;
						setPos();
	    			} else {
	    				container.visible = false;
	    				container2.visible = false;
	    			}
					//bitmap.visibility = (displayState == DisplayStates.Correct1);
					stage.update(event);
				});

				container.addChild(bitmap);
				container2.addChild(bitmap2);
				stage.addChild(container, container2);
				stage.update();

				let bWidth = 1000;

				let scale3 = ( stage.canvas.width * scale ) / bWidth;

				container.scaleX = scale3;
				container.scaleY = scale3;
				container2.scaleX = scale3;
				container2.scaleY = scale3;

	    		const canvasMid = stage.canvas.width * 0.5
	    		container.x = canvasMid ;
	    		container.y = 0;
	    		container2.x = canvasMid;
	    		container2.y = 0;

	    		let fontSize = 60 * scaleAnchorX / scale3;
	    		let sheng = new createjs.Text("h", fontSize+"px Hypy", "#000000"); //人\u97f3
				sheng.textBaseline = "alphabetic";

				let yun = new createjs.Text("eng", fontSize+"px Hypy", "#000000"); //人\u97f3
				yun.textBaseline = "alphabetic";

				container.addChild(sheng);
				container2.addChild(yun);

				let tween = undefined;
				let bounds = bitmap.getBounds();

				function setOnce() {
	    			container.x = stage.canvas.width * 0.25;
	    			container2.x = stage.canvas.width * 0.48;
	    			container.y = stage.canvas.height * 0.3;
	    			container2.y = stage.canvas.height * 0.3;

	    			bitmap.x = 0;
	    			bitmap.y = 0;
	    			bitmap2.x = 0;
	    			bitmap2.y = 0;

	    			tween = createjs.Tween.get(container2, { loop: true })
					   .to({ x:  stage.canvas.width * 0.40 }, 1000, createjs.Ease.getPowInOut(2))
					   .to({ x:  stage.canvas.width * 0.40 }, 200)
					   .to({ x:  stage.canvas.width * 0.48 }, 1000, createjs.Ease.getPowInOut(2))
					   .to({ x:  stage.canvas.width * 0.48 }, 200);
	    			setPos();
				}

				// update text position, text changes therefore their width height change as well
				function setPos() {
					sheng.y = sheng.getMeasuredHeight() * 1.2;
					yun.y = yun.getMeasuredHeight() * 1.2;

					sheng.x =  - sheng.getMeasuredWidth() * 0.5 + bWidth * 0.5;//stage.canvas.width * 0.5;
					yun.x = 0;
				}
				setOnce();
	    	}

	    	function bitmapCorrectSetup2b(stage) {
	    		//let scale = 1.5;
	    		//let wScale = 0.31 * 1.5;

	    		let scale = 0.47;
	    		let scale2 = 0.2;
	    		let container = new createjs.Container();
	    		let container2 = new createjs.Container();

	    		let bitmap = new createjs.Bitmap(imageDir+"correct_big.png");
	    		//bitmap.scaleX = 1;
	    		let bitmap2 = new createjs.Bitmap(imageDir+"tone_top1_correct.png");
	    		let bitmap3 = new createjs.Bitmap(imageDir+"tone_top2_correct.png");
	    		let bitmap4 = new createjs.Bitmap(imageDir+"tone_top3_correct.png");
	    		let bitmap5 = new createjs.Bitmap(imageDir+"tone_top4_correct.png");

	    		let tones = [bitmap2, bitmap3, bitmap4, bitmap5];

	    		let bWidth = 1000;
	    		let bHeight = 708;

				let scale3 = ( stage.canvas.width * scale ) / bWidth;
				let scale4 = ( stage.canvas.height * scale2 ) / bWidth;

				container.scaleX = scale3;
				container.scaleY = scale3;
				container2.scaleX = scale4;
				container2.scaleY = scale4;

	    		let fontSize = (60 * scaleAnchorX) / scale3;

	    		let sheng = new createjs.Text("ch", fontSize+"px Hypy", "#000000"); //人\u97f3
				sheng.textBaseline = "alphabetic";

				let yun = new createjs.Text("eng", fontSize+"px Hypy", "#000000"); //人\u97f3
				yun.textBaseline = "alphabetic";

	    		createjs.Ticker.addEventListener("tick", function(event) {
	    			//displayState = DisplayStates.Correct2;
	    			//console.log(displayState + " " + DisplayStates.Correct2);
	    			//console.log(container.scaleX + " " + bitmap2.scaleX);
	    			if (displayState === DisplayStates.Correct1) {
	    				container.visible = true;
	    				bitmap.visible = true;
	    				tones.forEach(function(e) {
	    					e.visible = false;
	    				});
	    				sheng.visible = true;
	    				yun.visible = true;
	    				let yunText = markerMapping[yunmuID];
						let shengText = markerMapping[shengmuID];
	    				sheng.text = shengText;
	    				yun.text = yunText;
	    			} else if (displayState === DisplayStates.Correct2) {
	    				container.visible = true;
	    				bitmap.visible = true;
	    				sheng.visible = true;
	    				yun.visible = true;
	    				tones.forEach(function(e) {
	    					e.visible = false;
	    				});
	    				if (toneID !== -1) {
	    					tones[toneID].visible = true;
	    				}
	    				let yunText = markerMapping[yunmuID];
						let shengText = markerMapping[shengmuID];
	    				sheng.text = shengText;
	    				yun.text = yunText;
	    			} else {
	    				container.visible = false;
	    				bitmap.visible = false;
	    				tones.forEach(function(e) {
	    					e.visible = false;
	    				});
	    				sheng.visible = false;
	    				yun.visible = false;
	    			}

	    			setPos();
					stage.update(event);
				});

				container.addChild(bitmap);
				tones.forEach(function(e) {
					container2.addChild(e);
				});
				container.addChild(sheng, yun);

				stage.addChild(container, container2);
				stage.update();

				container.x = stage.canvas.width * 0.5;
	    		container.y = stage.canvas.height * 0.3;
	    		container2.x = stage.canvas.width * 0.5;
	    		container2.y = stage.canvas.height * 0.3;

				//container.scaleX *= wScale;
				//container.scaleY *= wScale;

				//let toneWidth = bHeight * 0.28;
				//let toneHeight = scale4 / bWidth;

				let toneHeight = ( stage.canvas.height * scale2) / scale4;
				let cardWidth = stage.canvas.width * scale / scale4;

				console.log(["toneHeight", toneHeight]);

				function setPos() {
					bitmap.x = -bWidth * 0.5;
					bitmap.y = 0;

					sheng.y = sheng.getMeasuredHeight() * 1.2;
					yun.y = yun.getMeasuredHeight() * 1.2;

					sheng.x = -bWidth * 0.13 - sheng.getMeasuredWidth();
					yun.x = -bWidth * 0.12;

					tones.forEach(function(e) {
						//let ew = stage.canvas.height / 150 * 47;
						//ew = ew * wScale * 0.85;

						//e.y = -stage.canvas.height * 0.325;
						//e.y = - bWidth * 0.32;
						//e.y = -toneHeight;
						e.x = 0;
						e.y = -toneHeight;
						let yunText = markerMapping[yunmuID];
						//e.scaleX = scale4;
						//e.scaleY = scale4;
						// yun card left most 
						//e.x = -ew + stage.canvas.width * (0.5 - 0.63);

						// yun card right most 
						//e.x = -ew + stage.canvas.width * (0.5 - 0);
						if (yunmuVowelOnSecond.indexOf(yunText) !== -1) {
							//e.x = bounds2.width * -0.35; // position 2	
							//e.x = -ew + stage.canvas.width * (0.5 - 0.46);
							e.x = cardWidth * -0.07;
						} else {
							//e.x = bounds2.width * -1.05; // position 1 
							//e.x = -stage.canvas.width * 0.15;
							//e.x = -ew + stage.canvas.width * (0.5 - 0.57);
							e.x = cardWidth * -0.18;
						}
					});

					// 300, 126
					// 47, 150
					
				}

				setPos();
				stage.update();
	    	}

	    	function setupStatic(stage) {

	    		let cw = stage.canvas.width;
	    		let ch = stage.canvas.height;

	    		var line = new createjs.Shape();

            	// Add this line shape to the canvas
		        stage.addChild(line);

		        // Set the 'brush stroke' style (basically the thickness of the line)
		        //      Then start drawing a black line
		        //line.graphics.setStrokeStyle(2).beginStroke("rgba(0,0,0,1)");
		        line.graphics.setStrokeStyle(2 * scaleAnchorX).beginStroke("DimGrey");

		        // Tell EaselJS where to go to start drawing the line
		        line.graphics.moveTo(cw * 0.3, ch * 0.8);

		        // Tell EaselJS where to draw the line to
		        line.graphics.lineTo(cw * 0.7, ch * 0.8);

		        // Stop drawing this line
		        line.graphics.endStroke();

		        console.log("line drawn "+cw + " " + ch);


		//         var img = active ? img2 : img1;
		// ctx.drawImage(img, 
		// 	cw * (soundIconPosX - soundIconLength*0.5), 
		// 	ch * (soundIconPosY - soundIconLength*0.5), 
		// 	cw*soundIconLength, 
		// 	cw*((soundIconLength / 70) * 53));
				let soundInactiveBmp = new createjs.Bitmap(imageDir+"sound_inactive.png"); //sound_inactive
				let soundActiveBmp = new createjs.Bitmap(imageDir+"sound_active.png"); //sound_inactive

				stage.addChild(soundInactiveBmp, soundActiveBmp);

				let canvasMid = stage.canvas.width * 0.5;
		        stage.update();

		        function setPos() {
			  //       let bounds = soundInactiveBmp.getBounds();
			  //       if (bounds === null) {
					// 	setTimeout(function() {setPos();}, 1000);
					// 	return;
					// };
					// console.log("static");
					// console.log(bounds);
					// 70 53

					let iconWidth = stage.canvas.width * soundIconLength;
			  //   	soundInactiveBmp.x = canvasMid - bounds.width * 0.5;
					// soundInactiveBmp.y = stage.canvas.height * soundIconPosY - bounds.height * 0.5;
					// soundActiveBmp.x = canvasMid - bounds.width * 0.5;
					// soundActiveBmp.y = stage.canvas.height * soundIconPosY - bounds.height * 0.5 ;    
					soundInactiveBmp.x = canvasMid - iconWidth * 0.5;
					soundInactiveBmp.y = stage.canvas.height * soundIconPosY - iconWidth * 0.5 / 70 * 53;
					soundActiveBmp.x = canvasMid - iconWidth * 0.5;
					soundActiveBmp.y = stage.canvas.height * soundIconPosY - iconWidth * 0.5 / 70 * 53;

					let ratio = iconWidth / 70;

					soundInactiveBmp.scaleX = ratio;
					soundInactiveBmp.scaleY = ratio;
					soundActiveBmp.scaleX = ratio;
					soundActiveBmp.scaleY = ratio;
			    }
			    setPos();

			   	//drawCenterText(ctx, cw, ch, centerTextColor, displayText);
			 //   	if (text == "") return;
				// //ctx.fillStyle = "#ff0000";
				// ctx.fillStyle = color;
				// var fontSize = 75 * scaleAnchorX
				// ctx.font = fontSize+"px Hypy";
				// var setA = "ABCDE";
				// var setB = "FGHIJ";
				// var setC = "KLMNO";
				// var setD = "PQRST";
				// var setE = "UVWXY";
				// var setF = "Z_^`~|";

				// var textWidth = ctx.measureText(text).width;
				// console.log();
				// ctx.fillText(text, cw * 0.5 - textWidth * 0.5, ch * 0.7);

				var fontSize = 75 * scaleAnchorX;
				let textObj = new createjs.Text(displayText, fontSize+"px Hypy", "#000000"); //人\u97f3
				textObj.textBaseline = "alphabetic";
				//textObj.text = "heheh";
				
				stage.addChild(textObj);

			    createjs.Ticker.addEventListener("tick", function(event) {
	    			soundInactiveBmp.visible = !soundIconActive;
			    	soundActiveBmp.visible = soundIconActive;
			    	textObj.text = displayText;
			    	let textWidth = textObj.getMeasuredWidth();
					textObj.x = stage.canvas.width * 0.5 - textWidth * 0.5;
					textObj.y = stage.canvas.height * 0.8;

					if (displayState === DisplayStates.Correct1 || displayState === DisplayStates.Correct2) {
	    				textObj.color = "green";
	    				soundIconActive = false;
	    				if (displayState === DisplayStates.Correct2)
	    					soundIconActive = true;
	    			} else if (displayState === DisplayStates.Invalid || displayState === DisplayStates.Neutral) {
	    				textObj.color = "black";
	    				soundIconActive = false;
	    			} else { //if (displayState >=3 && displayState <= 8) 
	    				textObj.color = "red";
	    				soundIconActive = false;
	    			}

					stage.update(event);
				});
	    	}

			function easelSetup() {
				var stage = new createjs.Stage("myCanvas2");
				//setupCard(stage);
				//bitmapCorrectSetup1(stage);
				bitmapCorrectSetup2b(stage);
				setupStatic(stage);
				bitmapErrorSetup1b(stage);
				bitmapErrorSetup2b(stage);
				bitmapErrorSetup3b(stage);
				bitmapErrorSetup4b(stage);
				bitmapErrorSetup5b(stage);
			}

			function markerRecord(id, pos, vertex, timestamp, area) {
				var retval = {};
				retval.id = id;
				retval.pos = pos.slice();
				retval.vertex = cloneObj(vertex);
				retval.timestamp = timestamp;
				retval.area = area;
				return retval;
			}


			// trim arr that is longer than length len to len
			function shiftToLength(arr, len) {
				while(arr.length > len) {
					arr.shift();
				}
				return arr;
			}

			function percentValid(tonePosCheckHistory, invert, full) {

				if (tonePosCheckHistory === null) return 0;
				if (tonePosCheckHistory.length === 0) return 0;

				// only return real valid value after buffer is full
				if (full && tonePosCheckHistory.length < bufferSize) return 0;


				var validCount = 0;
				tonePosCheckHistory.forEach(function(b) {if (b) validCount++});
				var percent = validCount / tonePosCheckHistory.length;
				if (invert) return (1 - percent);

				//console.log((percent * 100)+ " percent valid here ");
				return percent;
			}

			function retireOld(history) {
				var stopFlag = false;
				while (history.length > 0 && !stopFlag) {
					var elapsed = Date.now() - history[0].timestamp;
					if (elapsed > 2000) {
						history.shift();
					} else {
						stopFlag = true;
					}
				}
			}

			function retireOld2(avgPos) {
				//console.log(Object.keys(avgPos).length);
				Object.keys(avgPos).forEach(function(key) {
			        var apos = avgPos[key];

			        if (apos === undefined)
			        	return;

			        var elapsed = Date.now() - apos.timestamp;

			        if (elapsed > 2000) {
						avgPos[key] = undefined;
					} else {
						stopFlag = true;
					}
			    });
			}

			function lerp(a, b, f)
			{
			    return a + f * (b - a);
			}

			function validCombiCheck(shengmuText, yunmuText) {
				if (shengmuText === "") return true;
				if (yunmuText === "") return true;
				//if (shengmuText == "" || yunmuText == "") return true;
				var arr = validCombi[shengmuText];
				if (arr === undefined) return false;
				return (arr.indexOf(yunmuText) !== -1);
			}

			function mappingFunction() {

				validCombi["n"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "g", "ian", "iang", "iao", "ie", "in", "ing", "iu", "ong", "ou", "u", "uan", "un", "uo", "v", "ve"];
				validCombi["l"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "eng", "i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iu", "ong", "ou", "u", "uan","un", "uo", "v", "ve"];
				validCombi["d"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ia", "ian", "iao", "ie", "ing", "iu", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["g"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["h"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["sh"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["t"] = ["ai", "an", "ang", "ao", "a", "e", "eng", "i", "ian", "iao", "ie", "ing", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["zh"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "ua", "uai", "uang", "ui", "un", "uo"];
				validCombi["m"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "iu", "o", "ou", "u"];
				validCombi["k"] = ["ai", "an", "ang", "ao", "a", "e", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["ch"] = ["ai", "an", "ang", "ao", "a", "e", "eng", "i", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["p"] = ["ai", "an", "ang", "ao", "a", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "o", "ou", "u"];
				validCombi["z"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["c"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["b"] = ["ai", "an", "ang", "ao", "a", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "o", "u"];
				validCombi["s"] = ["ai", "an", "ang", "ao", "a", "e", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["q"] = ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iang", "iong", "iu", "u", "uan", "ue", "un"];
				validCombi["y"] = ["an", "ang", "ao", "a", "e", "i", "in", "ing", "o", "ong", "ou", "u", "uan", "ue", "un"];
				validCombi["j"] = ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", "u", "uan", "ue", "un"];
				validCombi["x"] = ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", "u", "uan", "ue", "un"];
				validCombi["r"] = ["an", "ang", "ao", "e", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi[""] = ["ao", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "er", "o", "ou"];
				validCombi["f"] = ["an", "ang", "a", "ei", "en", "eng", "o", "ou", "u"];
				validCombi["w"] = ["ai", "an", "ang", "a", "ei", "en", "eng", "o", "u"];

				// verify that there is no typo in validCombi
				
				/// typo check 
				/*
				var result = true;
				shengmu.forEach(function(x) { 
					//console.log(validCombi[x]); 
					validCombi[x].forEach(function(y) {

						//result = result && yunmu.includes(y);
						//result = result && (yunmu.indexOf(y) != -1);

						if (typeof Array.prototype.includes === "function") { 
						    result = result && yunmu.includes(y);

						} else {
							result = result && (yunmu.indexOf(y) != -1);
						}
					}); 
				});

				// if true no typo in validCombi
				//console.log(result);
				*/
			}

			function cloneObj(obj) {
				return JSON.parse(JSON.stringify(obj));
			}

			// 20 marker width
			// 90 card width
			function markerWidth(id) {

				var x1 = markerTracked[id].vertex[1][0];
				var x2 = markerTracked[id].vertex[2][0];
				var x3 = markerTracked[id].vertex[3][0];
				var x4 = markerTracked[id].vertex[0][0];

				var dx1 = Math.abs(x2 - x1);
				var dx2 = Math.abs(x3 - x2);

				var dx3 = Math.abs(x4 - x3);
				var dx4 = Math.abs(x1 - x4);
			
				var dx_max = Math.max(dx1, dx2, dx3, dx4);
				return dx_max;
			}

			function markerWidth2(id) {
				var x1 = markerTracked[id].vertex[0][0];
				var y1 = markerTracked[id].vertex[0][1];
				var x2 = markerTracked[id].vertex[1][0];
				var y2 = markerTracked[id].vertex[1][1];
				var x3 = markerTracked[id].vertex[2][0];
				var y3 = markerTracked[id].vertex[2][1];
				var x4 = markerTracked[id].vertex[3][0];
				var y4 = markerTracked[id].vertex[3][1];

				var dx1 = Math.abs(x1-x2);
				var dx2 = Math.abs(x2-x3);
				var dx3 = Math.abs(x3-x4);
				var dx4 = Math.abs(x4-x1);

				var dy1 = Math.abs(y1-y2);
				var dy2 = Math.abs(y2-y3);
				var dy3 = Math.abs(y3-y4);
				var dy4 = Math.abs(y4-y1);

				//console.log([dx1, dy1, dx2, dy2, dx3, dy3, dx4, dy4]);

				var d1 = dx1*dx1 + dy1*dy1;
				var d2 = dx2*dx2 + dy2*dy2;
				var d3 = dx3*dx3 + dy3*dy3;
				var d4 = dx4*dx4 + dy4*dy4;

				//console.log([d1, d2, d3, d4]);
			
				var dx_max = Math.max(d1, d2, d3, d4);
				return Math.sqrt(dx_max);
			}

			function leftMostVectex(id) {
				var x1 = markerTracked[id].vertex[0][0];
				var x2 = markerTracked[id].vertex[1][0];
				var x3 = markerTracked[id].vertex[2][0];
				var x4 = markerTracked[id].vertex[3][0];

				var left = Math.min(x1, x2, x3, x4);
				if (left === x1) return markerTracked[id].vertex[0];
				if (left === x2) return markerTracked[id].vertex[1];
				if (left === x3) return markerTracked[id].vertex[2];
				if (left === x4) return markerTracked[id].vertex[3];
			}

			function cloneTransform(src, dest) {
				//var newObj = new THREE.Object3D();
				var pos = src.getWorldPosition();
				var quat = src.getWorldQuaternion();
				//console.log(newObj.matrixAutoUpdate);
				//console.log(pos);

				var parent = src.parent;
				THREE.SceneUtils.detach(dest, dest.parent, scene);

				dest.position.set(pos.x, pos.y, pos.z);
				dest.quaternion.set(quat.x, quat.y, quat.z, quat.w);

				parent.add(dest);
				//console.log(newObj.position);
			}

			function shengYunDistance(shengmuID, yunmuID) {
				if (markerTracked[shengmuID] !== undefined && markerTracked[yunmuID] !== undefined) {
					var mw = markerWidth2(yunmuID);
					var mw2 = markerWidth2(shengmuID);

					mw = (mw + mw2) / 2;
					var cardWidth = mw / 20 * 90;
					var cardSixth = cardWidth / 6;

					const canvasWidth = 640;
					var maxOffset = mw / 6;

					var shengX = markerTracked[shengmuID].pos[0] ;
					var yunX = markerTracked[yunmuID].pos[0] ;

					var diff = Math.abs(shengX - yunX);
					//console.log(diff + " " + cardWidth + " " + diff / cardWidth);
					return diff / cardWidth;

					// dependent on orientation
					//var cardLeft = markerTracked[yunmuID].pos[0] - cardSixth ;
					//var correctX = toneMarkerTarget[yunmuID] * 1.05; // hack that works well

					//var debugOffset = toneMarkerTarget[yunmuID] * 0.05;

					//var cardproper = cardLeft + ((correctX/90) * cardWidth) ;
					//var cardproper = cardLeft + ((56/90) * cardWidth);
					//var error = Math.abs(cardproper - markerX);
				}
			}

			function screenSpaceCheck(toneID, yunmuID) {

				if (markerTracked[toneID] !== undefined && markerTracked[yunmuID] !== undefined) {

					var mw = markerWidth2(yunmuID);
					var mw2 = markerWidth2(toneID);

					mw = (mw + mw2) / 2;
					var cardWidth = mw / 20 * 90;
					var cardSixth = cardWidth / 6;
					

					const canvasWidth = 640;
					var maxOffset = mw / 6;

					var horiDeviate = (markerTracked[yunmuID].pos[0] - 320) / 320;

					var correction =  (horiDeviate < 0) ? (horiDeviate * maxOffset * -1) : 0;

					var horiDeviate2 = (markerTracked[toneID].pos[0] - 320) / 320;
					var correction2 =  (horiDeviate2 < 0) ? (horiDeviate2 * maxOffset * -1) : 0;;

					// remove change for now
					correction = 0;
					correction2 = 0;

					var markerX = markerTracked[toneID].pos[0] + correction2;

					// dependent on orientation
					var cardLeft = markerTracked[yunmuID].pos[0] - cardSixth + correction;
					var correctX = toneMarkerTarget[yunmuID] * 1.05; // hack that works well

					//var debugOffset = toneMarkerTarget[yunmuID] * 0.05;

					var cardproper = cardLeft + ((correctX/90) * cardWidth) + correction;
					//var cardproper = cardLeft + ((56/90) * cardWidth);
					var error = Math.abs(cardproper - markerX);

					//const thresh = 10;
					thresh = (mw / 20 ) * 8;

					if (debugMode) {
						/*
						var leftMostPt = leftMostVectex(yunmuID);
						ctx.strokeStyle = 'blue';
						ctx.lineWidth = 2;
						ctx.beginPath();
						ctx.moveTo(cardLeft * scaleAnchorX, leftMostPt[1]);
						ctx.lineTo(cardLeft * scaleAnchorX, 4000);
						ctx.stroke();
						*/
					
						ctx.strokeStyle = 'blue';
						ctx.lineWidth = 2;
						ctx.beginPath();
						ctx.moveTo((cardLeft ) * scaleAnchorX, 0);
						ctx.lineTo((cardLeft ) * scaleAnchorX, 4000);
						ctx.stroke();

						ctx.lineWidth = 2;
						ctx.beginPath();
						ctx.moveTo((cardLeft + cardWidth ) * scaleAnchorX, 0);
						ctx.lineTo((cardLeft + cardWidth ) * scaleAnchorX, 4000);
						ctx.stroke();

						ctx.strokeStyle = 'green';
						ctx.beginPath();
						ctx.moveTo(cardproper * scaleAnchorX, 0);
						ctx.lineTo(cardproper * scaleAnchorX, 4000);
						ctx.stroke();

						ctx.strokeStyle = 'red';
						ctx.beginPath();
						ctx.moveTo(markerX * scaleAnchorX, 0);
						ctx.lineTo(markerX * scaleAnchorX, 4000);
						ctx.stroke();
					}

					return (error < thresh && error > 0);
				} else {
					console.log("screenSpaceCheck called when marker does not exist in markerTracked");
					return false; // error state
				}
			}

			// 3d solution
			function space3DCheck() {
				var scene = arScene.scene;
				var anchor = scene.children[2];
				var child2 = anchor.children[1];
				var child3 = anchor.children[2];

				var wp3 = child3.getWorldPosition();
				var child2InChild3Local = child2.worldToLocal(wp3);
				//console.log(child2InChild3Local.x);
				var targetX = ((56 - 15) / 20);
				//console.log(targetX);
				var error = Math.abs(child2InChild3Local.x  - targetX);
				//console.log(error);

				const thresh = 6/20;
				return (error <= thresh)
			}

			// pinyin is the string to change, vowelIndex 0 for first vowel, 1 for second, 2 for third
			// tone 1 2 3 4
			function markTheVowel(pinyin, vowelIndex, tone) {

				//  a i o e u
				const setA = "ABCDE";
				const setB = "FGHIJ";
				const setC = "KLMNO";
				const setD = "PQRST";
				const setE = "UVWXY";
				const setF = "Z_^`~|";

				var tokenized = [];
				//var vowelFiltered = "";
				tokenized = pinyin.split("");
				var vowelFiltered = tokenized.filter(c => (c === "a" || c === "e" || c === "i" || c === "o" || c === "u" || c === "v"));

				if (pinyin === "") return "";
				//console.log(vowelFiltered + " " + vowelFiltered.length);
				if (vowelIndex >= vowelFiltered.length) {
					console.log("markTheVowel invalid vowelIndex "+vowelIndex);
					return pinyin;
				}

				var targetVowel = vowelFiltered[vowelIndex];

				var setChosen = "";
				if (targetVowel === "a") setChosen = setA;
				else if (targetVowel === "i") setChosen = setB;
				else if (targetVowel === "o") setChosen = setC;
				else if (targetVowel === "e") setChosen = setD;
				else if (targetVowel === "u") setChosen = setE;

				return pinyin.replace(targetVowel, setChosen[tone-1]);
				//return setA + setB + setC + setD + setE + setF;
			}

			function rotZ(id) {
				var scene = arScene.scene;
				//var anchor = scene.children;
				//console.log(scene);

				//var child2 = anchor.children[1];
				//var child3 = anchor.children[2];

				function findMarkerRoot(scene, id) {
					if (scene.children === null) return;	
					//var retval = null;
					var retval = scene.children.find(function (child) {
						
						if (child.markerID !== undefined) {
							return child.markerID === id;
							//console.log(id + " " + child.markerID);
							//if (child.markerID == id) {
								//retval = child;
								//return child;
							//}
						} else return false;
					});
					return retval;
				}

				var marker = findMarkerRoot(scene, id);
				//var toneMarker = findMarkerRoot(scene, toneID);

				var worldRot = marker.getWorldRotation();
				const rad2deg = (180 / Math.PI);

				var rotVal = worldRot.toVector3().multiplyScalar(rad2deg).z;
				return rotVal;
			}

			// not working already 
			function threeDimensionAlternative(toneID, yunmuID) {

				//var check = screenSpaceCheck() || space3DCheck();
				
				/*if (check) {
					console.log("correct");
					ctx.fillStyle = 'green';
					ctx.font = "50px Arial";
					ctx.fillText("correct",320,100);
				} else {
					console.log("wrong");
					ctx.fillStyle = 'red';
					ctx.font = "50px Arial";
					ctx.fillText("wrong",320,100);
				}*/

				

				if (avgPos[toneID] === undefined || avgPos[yunmuID] === undefined) return;
				 /*
				var scene = arScene.scene;
				var yunmuMarker = findMarkerRoot(scene, yunmuID);
				var toneMarker = findMarkerRoot(scene, toneID);
				var worldRot = yunmuMarker.getWorldRotation();
				const rad2deg = (180 / Math.PI);
				var rotVal = worldRot.toVector3().multiplyScalar(rad2deg).z;
				*/
				var notMarkerPos = new THREE.Vector2(avgPos[toneID][0], avgPos[toneID][1]);
				

				var rotVal = rotZ(yunmuID);

				var projection = 0;
				var dir = null;
				var dirLen = 0;
				var v = null;
				var v1, v2, v3, v4;

				var v0raw = avgVertex[yunmuID][0];
				var v1raw = avgVertex[yunmuID][1];
				var v2raw = avgVertex[yunmuID][2];
				var v3raw = avgVertex[yunmuID][3];

				v0 = new THREE.Vector2(v0raw[0], v0raw[1]);
				v1 = new THREE.Vector2(v1raw[0], v1raw[1]);
				v2 = new THREE.Vector2(v2raw[0], v2raw[1]);
				v3 = new THREE.Vector2(v3raw[0], v3raw[1]);

/*
				console.log(62 + " " + "here");
				console.log(v0raw);
				console.log(v1raw);
				console.log(v2raw);
				console.log(v3raw);

				console.log(63 + " " + "here");
				console.log( avgVertex[63][0]);
				console.log( avgVertex[63][1]);
				console.log( avgVertex[63][2]);
				console.log( avgVertex[63][3]);
*/							

				// do not change the order of if else condition check,
				// (if rotVal > 90 not checked first, rotVal >=0 will need another && rotVal <= 90)
				if (rotVal > 90) { // tilt left
					// 0 1
					dir = v1.sub(v0);
					dirLen = dir.length();
					dirNorm = dir.normalize();

					v = notMarkerPos.sub(v0).divideScalar(dirLen * (9/2));
					projection = v.dot(dir);
				} else if (rotVal >= 0) { // tilt right on hand
					// 1 2
					dir = v2.sub(v1);
					dirLen = dir.length();
					dirNorm = dir.normalize();
					v = notMarkerPos.sub(v1).divideScalar(dirLen * (9/2));
					projection = v.dot(dir);
				} else if (rotVal < -90) {// tilt left upside down
					// 3 4
					dir = v0.sub(v3);
					dirLen = dir.length();
					dirNorm = dir.normalize();
					v = notMarkerPos.sub(v3).divideScalar(dirLen * (9/2));
					projection = v.dot(dir);
				} else if (rotVal < 0) { // tilt right upside down
					// 2 3
					dir = v3.sub(v2);
					dirLen = dir.length();
					dirNorm = dir.normalize();
					v = notMarkerPos.sub(v2).divideScalar(dirLen * (9/2));
					projection = v.dot(dir);
				}


				var correctX = toneMarkerTarget[yunmuID];
				var cardproper = (correctX/90);

				//console.log(yunmuID);
				//console.log(correctX)
				//console.log(cardproper);
				//console.log(projection);

				//console.log(dirLen);
				//console.log(dir);
				//console.log(v);

				// in the ratio of a card len
				var error  = Math.abs(projection - cardproper);
				var thresh = 10/90;
				//console.log(error);

				//console.log("");
				return (error < thresh);
			}
			
			function consoleDebug(markerTracked) {
				var keyList = Object.keys(markerTracked);
				if (keyList.length > 0)
					//console.log(keyList);
					console.log(keyList.length);
			}


			function tick(ctx) {
				
				//ctx.fillStyle = 'white';
				//ctx.clearRect(0,0,canvasWidth,canvasHeight);
				//printFeedback(ctx, canvasWidth, canvasHeight);
				//printError(ctx, canvasWidth, canvasHeight, displayState);

				arScene.process(ctx);
				arScene.renderOn(renderer);
				requestAnimationFrame(function () {
					tick(ctx); 
				});
				
				displayState = DisplayStates.Invalid;
				//displayState = DisplayStates.ErrorCombi;
				//displayState = DisplayStates.ErrorTonePos;
				//displayState = DisplayStates.ErrorNoTone;
				//displayState = DisplayStates.ErrorSwapped;
				//displayState = DisplayStates.ErrorTooNear;


				var markerNum = arController.getMarkerNum();

				// reset data
				markerTracked = {};
				yunmuSlot.length = 0;
				shengmuSlot.length = 0;
				toneSlot.length = 0;
				yunmuText = "";
				shengmuText = "";
				soundName = "";
				displayText = "";
				
				//retireOld(history);
				//retireOld2(avgPos);

				for (var i = 0; i<markerNum ; i++) {
					var markerInfo = arController.getMarker(i);
					var vertex = markerInfo.vertex;
					var pos = markerInfo.pos;
					var id = markerInfo.id;
					var area = markerInfo.area;
					var newMarkerRecord = null;

					if (id !== -1) {
						newMarkerRecord = markerRecord(id, pos, vertex, Date.now(), area);
						markerTracked[id] = newMarkerRecord;

						// lerping position 
						// TODO eventually i need to do some kind of moving window average
						//avgPos[id] = pos.slice();
						//avgVertex[id] = cloneObj(vertex);

						// categorizing markers into 3 types
						if (id >= 0 && id <= 3) {
							toneSlot.push(id);
						} else if (id >= 4 && id <= 38) {
							yunmuSlot.push(id);
						} else if (id >= 39 && id <= 61) {
							shengmuSlot.push(id);
						}
					}

					if (debugMode) {
						drawMarkerOutline(ctx, vertex, pos, id);
						var mycanvas2 = document.getElementById("myCanvas2");
						mycanvas2.style.backgroundColor = 'rgba(255,255,255,0)';
					}
				}

				// exit if there are duplicate yunmu or shengmu or tone
				if (yunmuSlot.length > 1) {
					console.log("duplicate yunmu "+yunmuSlot);
					yunmuSlot.forEach(function(e) {
						console.log(markerMapping[e]);
					});
					return;
				}
				if (shengmuSlot.length > 1) {
					console.log("duplicate shengmu "+shengmuSlot);
					shengmuSlot.forEach(function(e) {
						console.log(markerMapping[e]);
					});
					return;
				}
				if (toneSlot.length > 1) {
					console.log("duplicate tone "+toneSlot);
					return;	
				}

				var shengmuText = (shengmuSlot.length > 0) ? markerMapping[shengmuSlot[0]] : "";
				var yunmuText = (yunmuSlot.length > 0) ? markerMapping[yunmuSlot[0]] : "";

				//yunmuID = markerMapping.indexOf(yunmuText);
				//shengmuID = markerMapping.indexOf(shengmuText);;
				shengmuID = (shengmuSlot.length > 0) ? shengmuSlot[0] : -1;
				yunmuID = (yunmuSlot.length > 0) ? yunmuSlot[0] : -1;

				var leftText = "";
				var rightText = "";

				if (yunmuID !== -1 && shengmuID !== -1) { // both components are there
					var yposX = markerTracked[yunmuID].pos[0];
					var sposX = markerTracked[shengmuID].pos[0];
					leftText = (sposX < yposX) ? yunmuText : shengmuText;
					rightText = (sposX < yposX) ? shengmuText : yunmuText;

					if (leftText === yunmuText || rightText === shengmuText) {
						errorCode = 3;
						displayState = DisplayStates.ErrorSwapped;
						displayText = leftText + shengmuText;
						//drawCenterText(width, height, 'red', leftText + shengmuText);
						return;
					}
				} else { // either one of them missing or both
					leftText = shengmuText;
					rightText = yunmuText;
				}

				//for debug
				//console.log(threeDimensionAlternative(toneID, yunmuID));
				//console.log(screenSpaceCheck(toneID, yunmuID));

				var combined = leftText + rightText;

				// don't even go to the combi check if one of them is not set
				//if (yunmuText == "" || shengmuText == "") return;
				
				if (yunmuText === "" && shengmuText === "") {
					validCheckHistory.length = 0;
					return;
				}

				// short circuit when either yunmu and shengmu not on screen
				if ((yunmuText !== "" && shengmuText === "")
					|| (yunmuText === "" && shengmuText !== ""))
				{
					//drawCenterText(width, height, 'black', combined);
					displayState = DisplayStates.Neutral;
					displayText = combined;
					tonePosCheckHistory.length = 0; // clear history
					return;
				}

				// a small set of yunmu has notation on the second
				var vowelIndex = (yunmuVowelOnSecond.indexOf(yunmuText) !== -1) ? 1 : 0;
				

				var shengYunDist = shengYunDistance(shengmuID, yunmuID);

				var ysSpaceCheck = false;
				if (shengmuText.length == 2) {
					if (shengYunDist < 1.36 || shengYunDist > 1.47) {
						ysSpaceCheck = true;
					}
				} else {
					if (shengYunDist < 1.24 || shengYunDist > 1.36) {
						ysSpaceCheck = true;
					}
				}
				//ysSpaceCheck = true;
				//ysSpaceCheckHistory
				ysSpaceCheckHistory.push(ysSpaceCheck);
				shiftToLength(ysSpaceCheckHistory, bufferSize);
				var ysCheckRatio = percentValid(ysSpaceCheckHistory, false, false);
				//console.log(shengYunDist + " " + ysCheckRatio + " " + ysSpaceCheck);
				if (ysCheckRatio > 0.7) {
					displayState = DisplayStates.ErrorTooNear;
					displayText = combined;
					//console.log("s2 "+ shengYunDist + " " + displayText);
					return;
				}

				var validCheckResult = validCombiCheck(shengmuText, yunmuText);
				//console.log(validCheckResult);
				toneID = (toneSlot.length > 0) ? toneSlot[0] : -1;

				validCheckHistory.push(validCheckResult);
				shiftToLength(validCheckHistory, bufferSize);

				var pv = percentValid(validCheckHistory, false, false);
				if (pv < 0.2) {
					errorCode = 0;
					displayState = DisplayStates.ErrorCombi;
					displayText = combined;
					return;
				} else {
					displayState = DisplayStates.Neutral;
					// can't get beyond this point without tone marker
					if (toneID === -1) {
						displayState = DisplayStates.Correct1;
						displayText = combined;
						tonePosCheckHistory.length = 0; // clear history
						ysSpaceCheckHistory.length = 0;
						return;
					}
				}

				var toneName = (toneID + 1);
				if (isNaN(toneName)) return;
				soundName = combined + toneName;

				var noToneTest = (validButNoTone.indexOf(soundName) !== -1);

				if (noToneTest) {
					errorCode = 2;
					displayState = DisplayStates.ErrorNoTone;
					displayText = combined;
					return;
				}

				var markedPinyin = markTheVowel(combined, vowelIndex, toneID + 1);
				var simpleTest = screenSpaceCheck(toneID, yunmuID);
				
				//var complicatedTest = threeDimensionAlternative(toneID, yunmuID);
				
				//var horiResult = horiTest (toneID, yunmuID, shengmuID);
				
				tonePosCheckHistory.push(simpleTest);
				shiftToLength(tonePosCheckHistory, bufferSize);
				
				var stableTest = (percentValid(tonePosCheckHistory) > 0.5);
				//var tonePosCheck = (simpleTest || complicatedTest);

				if (!stableTest) {
					errorCode = 1;
					displayState = DisplayStates.ErrorTonePos;
					displayText = combined;
					return;
				}

				if (stableTest && !noToneTest) {
					displayState = DisplayStates.Correct2;
					displayText = markedPinyin;
					if (prevSoundName !== soundName) {
						playSound(soundName);
						prevSoundName = soundName;
					}
				}
			}
		}
	}); // end of get getUserMediaThreeScene

	delete window.ARThreeOnLoad;
};

function onload() {
	if (window.ARController && ARController.getUserMediaThreeScene) {
		window.ARThreeOnLoad();
	}
}

</script>
</html>