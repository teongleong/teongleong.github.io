<html>
<head>
<title>HYPY</title>
<link rel="shortcut icon" href="#" />
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<style>
html,body {
	margin: 0;
	padding: 0;
	width: 100%;
	text-align: center;
	overflow-x: hidden;
}
.portrait canvas {
	transform-origin: 0 0;
	transform: rotate(-90deg) translateX(-100%);
}
.desktop canvas {
 	transform: scale(1, 1);
}
#myCanvas2 {
	background: rgba(255,255,255,255);
	position: absolute;
	z-index: 1;
	border: 1px solid black;
	border-width: 2px;
	border-style: groove;
	transform: scale(1, 1);
}

#mainTable {
  position: relative;
  padding: 8px;
}

@font-face { font-family: Hypy; src: url('fonts/Hypy.ttf'); }



</style>
</head>
<body bgcolor="white">
<table align="center">
<tr><td id="mainTable">
<canvas id="myCanvas2"></canvas>
</td></tr>
<video id="gum-local" autoplay playsinline hidden></video>
</table>
<h1>Hanyu Pinyin</h1>

<script async src="https://cdn.jsdelivr.net/npm/jsartoolkit@0.0.0/build/artoolkit.min.js"></script>
<script async src="https://cdn.jsdelivr.net/npm/jsartoolkit@0.0.0/examples/js/third_party/three.js/three.min.js"></script>
<script async src="https://cdn.jsdelivr.net/npm/jsartoolkit@0.0.0/js/artoolkit.three.js"></script>

<script>

window.ARThreeOnLoad = function() {

	ARController.getUserMediaThreeScene({
		maxARVideoSize: 640,
		cameraParam: 'data/camera.dat',
		onSuccess: function(arScene, arController, arCamera) {
			
			var markerTracked = {};
			//var prevMarkerTracked = {};
			var longTermTracking = {};
			var history = [];
			var avgPos = {};
			var avgVertex = {};

			
			var renderer = new THREE.WebGLRenderer({antialias: true});

			var cardLen = 1;
			var ref1 = -88;
			var ref2 = -99;
		

			arSetup(arController, renderer);
			
			const rendererCanvas = renderer.domElement;
			const width = rendererCanvas.clientWidth;
			const height = rendererCanvas.clientHeight;  
			console.log(width + " " + height );

			var overlay = document.getElementById("myCanvas2");
			var ctx = overlay.getContext('2d');
			//ctx.scale(0.5, 0.5);

			overlay.width = width;
			overlay.height = height;
			var canvasWidth = width;
			var canvasHeight = height;

			var seenMarker = {};
			yunmuSlot = [];
			shengmuSlot = [];
			toneSlot = [];

			var validCombi = [];
			var yunmu = [
				"ai", "an", "ang", "ao", "a", 
				"e", "ei", "en", "eng", "er", 
				"i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", 
				"o", "ong", "ou", 
				"u", "ua", "uai", "uan", "uang", "ue", "ui", "un", "uo", 
				"v", "ve",
				"g"
			];

			var shengmu = [
				"", "b", "c", "ch", "d", "f", "g", "h", "j", "k", "l", "m", 
				"n", "p", "q", "r", "s", "sh", "t", "w", "x", "y", "z", "zh"
			];
			//var validCombiAlt = [];

			const markerMapping = ["tone1", "tone2", "tone3", "tone4",
								"iang", "iong", "uang",
								"ang", "eng", "ong", "uai", "uan", "ian", "iao", "ing", 
								"ia", "ie", "in", "ai", "an", "ao", "ei", "en", "er", "iu",
								"ou", "ua", "ue", "ui", "un", "uo", "ve", 
								"a", "e", "i", "o", "u", "v", "g",
								"B", "C", "Ch", "D", "F", "G", "H", "J", "K", "L",
								"M", "N", "P", "Q", "R", "S", "Sh", "T", "W", "X",
								"Y", "Z", "Zh"];

			const toneMarkerTarget = [-1, -1, -1, -1, 66.4, 66.1, 55.5,
								77.6, 78.2, 78.2, 55.5, 55.5, 65.6, 65.5, 83.1, 
								66.4, 66.1, 83.1, 77.6, 77.6, 77.6, 78.2, 78.2, 78.2, 66.2,
								78.2, 55.5, 56.1, 61.1, 78.2, 78.2, 57.8, 
								77,6, 78.2, 83.1, 78.2, 78.2, 78.9, 78.6];

			sceneSetup(arScene);
			tick(ctx);
			mappingFunction();

			var marker0;
			var obj3d;
			
			function arSetup(arController, renderer) {
				document.body.className = arController.orientation;
				//arController.setPatternDetectionMode(artoolkit.AR_TEMPLATE_MATCHING_MONO_AND_MATRIX);

				arController.setPatternDetectionMode(artoolkit.AR_MATRIX_CODE_DETECTION);
				//arController.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_4x4_BCH_13_5_5);
				//arController.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_4x4);
				//arController.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_4x4_BCH_13_9_3);
				//arController.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_3x3);

				arController.borderStyle = "white";
				
				// setting renderer size
				
				if (arController.orientation === 'portrait') {
					var w = (window.innerWidth / arController.videoHeight) * arController.videoWidth;
					var h = window.innerWidth;
					renderer.setSize(w, h);
					renderer.domElement.style.paddingBottom = (w-h) + 'px';
				} else {
					if (/Android|mobile|iPad|iPhone/i.test(navigator.userAgent)) {
						renderer.setSize(window.innerWidth, (window.innerWidth / arController.videoWidth) * arController.videoHeight);
					} else {
						renderer.setSize(arController.videoWidth, arController.videoHeight);
						document.body.className += ' desktop';
					}
				}

				// my simple resize test
				//var w = (window.innerWidth / arController.videoHeight) * arController.videoWidth;
				//var h = window.innerWidth;

				/*var h = window.innerHeight;
				var w = window.innerHeight * (arController.videoWidth / arController.videoHeight);
				renderer.setSize(w, h);*/
				
				// add three js renderer to main_table
				var mainTable = document.getElementById("mainTable");
				mainTable.appendChild(renderer.domElement, mainTable);
			}
			
			function sceneSetup(arScene) {
				/*
				var material = new THREE.LineBasicMaterial({ color: 0x0000ff });
				var geometry = new THREE.Geometry();
				geometry.vertices.push(new THREE.Vector3(0, 0, 0));
				geometry.vertices.push(new THREE.Vector3(0, 100, 100));
				geometry.vertices.push(new THREE.Vector3(0, 100, -100));
				var line = new THREE.Line(geometry, material);
				arScene.scene.add(line);
				*/

				var sphere = new THREE.Mesh(
					new THREE.SphereGeometry(0.5, 10, 10),
					new THREE.MeshNormalMaterial()
				);
				sphere.material.shading = THREE.FlatShading;
				sphere.position.z = 1.0;

				var torus = new THREE.Mesh(
					new THREE.TorusGeometry(0.1*2.5, 0.2*2.0, 10, 10),
					new THREE.MeshNormalMaterial()
				);
				torus.material.shading = THREE.FlatShading;
				torus.position.z = 1.25;
				torus.rotation.x = Math.PI/2;
				
				var cube = new THREE.Mesh(
					new THREE.BoxGeometry(1,1,1),
					new THREE.MeshNormalMaterial()
				);
				cube.material.shading = THREE.FlatShading;
				cube.position.z = 0.5;


				//var obj3dRoot = new THREE.Object3D();

				// debug scene with obj3d
				/*obj3d = new THREE.Mesh(
					new THREE.TorusGeometry(0.1*2.5, 0.2*2.0, 10, 10),
					new THREE.MeshNormalMaterial()
				);
				obj3d.material.shading = THREE.FlatShading;
				obj3d.position.z = 20;*/
				//obj3d.rotation.x = Math.PI/2;


				//obj3dRoot.add(obj3d);

				//obj3dRoot.setAngularVelocity(new THREE.Vector3(0, 90, 0));
				//arScene.scene.add(obj3d);

				// create markers with id 0, 1, 2
				// anchor primitive shapes to marker
				//var markerRoot0 = arController.createThreeBarcodeMarker(61);
				//markerRoot0.add(sphere);
				//arScene.scene.add(markerRoot0);

				
				//var markerRoot1 = arController.createThreeBarcodeMarker(62);
				//markerRoot1.add(torus);
				//arScene.scene.add(markerRoot1);
				//marker0 = markerRoot1;
				
				//var markerRoot2 = arController.createThreeBarcodeMarker(63);
				//markerRoot2.add(cube);
				//arScene.scene.add(markerRoot2);

				//test obj root 
				
				/*
				testObj = new THREE.Object3D();
				
				testObj.add(markerRoot0);
				testObj.add(markerRoot1);
				testObj.add(markerRoot2);
				//arScene.scene.add(testObj);

				var clone1 = new THREE.Object3D();
				var clone2 = new THREE.Object3D();
				var clone3 = new THREE.Object3D();

				testObj.add(clone1);
				testObj.add(clone2);
				testObj.add(clone3);
				*/

				for(var i=0; i<62; i++) {
					var markerRoot = arController.createThreeBarcodeMarker(i);
					markerRoot.markerID = i;
					arScene.scene.add(markerRoot);
				}
			}

			function markerRecord(id, pos, vertex, timestamp, area) {
				var retval = [];
				retval.id = id;
				retval.pos = pos.slice();
				retval.vertex = cloneObj(vertex);
				retval.timestamp = timestamp;
				retval.area = area;
				return retval;
			}

			function retireOld(history) {
				var stopFlag = false;
				while (history.length > 0 && !stopFlag) {
					var elapsed = Date.now() - history[0].timestamp;
					if (elapsed > 2000) {
						history.shift();
					} else {
						stopFlag = true;
					}
				}
			}

			function retireOld2(avgPos) {
				//console.log(Object.keys(avgPos).length);
				Object.keys(avgPos).forEach(function(key) {
			        var apos = avgPos[key];

			        if (apos == undefined)
			        	return;

			        var elapsed = Date.now() - apos.timestamp;

			        if (elapsed > 2000) {
						avgPos[key] = undefined;
					} else {
						stopFlag = true;
					}
			    });
			}

			function lerp(a, b, f)
			{
			    return a + f * (b - a);
			}

			function printAvgPos() {

				/*for (apos in avgPos) {
        			ctx.beginPath();
					ctx.arc(apos[0], apos[1], 8, 0, Math.PI * 2);
					ctx.fillStyle = "#00ff00";
					ctx.fill();
					ctx.fillText(id,apos[0],apos[1])
				}*/

				Object.keys(avgPos).forEach(function(key) {
			        var apos = avgPos[key];
			        if (apos == undefined)
			        	return;
			        ctx.font = "25px Arial";
			        ctx.beginPath();
					ctx.arc(apos[0], apos[1], 8, 0, Math.PI * 2);
					ctx.fillStyle = "#00ff00";
					ctx.fill();
					ctx.fillText(key,apos[0],apos[1]);
			    });
        		/*
				avgPos.forEach(function(apos) {
					//ctx.strokeStyle = 'green';
					ctx.beginPath();
					ctx.arc(apos[0], apos[1], 8, 0, Math.PI * 2);
					ctx.fillStyle = "#00ff00";
					ctx.fill();
					ctx.fillText(id,apos[0],apos[1])
				});*/
			}

			function toUTF16(codePoint) {
			    var TEN_BITS = parseInt('1111111111', 2);
			    function u(codeUnit) {
			        return '\\u'+codeUnit.toString(16).toUpperCase();
			    }

			    if (codePoint <= 0xFFFF) {
			        return u(codePoint);
			    }
			    codePoint -= 0x10000;

			    // Shift right to get to most significant 10 bits
			    var leadSurrogate = 0xD800 + (codePoint >> 10);

			    // Mask to get least significant 10 bits
			    var tailSurrogate = 0xDC00 + (codePoint & TEN_BITS);

			    return u(leadSurrogate) + u(tailSurrogate);
			}

			function validCombiCheck(shengmuText, yunmuText) {
				var arr = validCombi[shengmuText];
				if (arr == undefined) return false;
				return (arr.indexOf(yunmuText) != -1);
			}

			function mappingFunction() {

				validCombi["n"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "g", "ian", "iang", "iao", "ie", "in", "ing", "iu", "ong", "ou", "u", "uan", "un", "uo", "v", "ve"];
				validCombi["l"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "eng", "i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iu", "ong", "ou", "u", "uan","un", "uo", "v", "ve"];
				validCombi["d"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ia", "ian", "iao", "ie", "ing", "iu", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["g"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["h"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["sh"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["t"] = ["ai", "an", "ang", "ao", "a", "e", "eng", "i", "ian", "iao", "ie", "ing", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["zh"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "ua", "uai", "uang", "ui", "un", "uo"];
				validCombi["m"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "iu", "o", "ou", "u"];
				validCombi["k"] = ["ai", "an", "ang", "ao", "a", "e", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["ch"] = ["ai", "an", "ang", "ao", "a", "e", "eng", "i", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["p"] = ["ai", "an", "ang", "ao", "a", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "o", "ou", "u"];
				validCombi["z"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["c"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["b"] = ["ai", "an", "ang", "ao", "a", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "o", "u"];
				validCombi["s"] = ["ai", "an", "ang", "ao", "a", "e", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["q"] = ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iang", "iong", "iu", "u", "uan", "ue", "un"];
				validCombi["y"] = ["an", "ang", "ao", "a", "e", "i", "in", "ing", "o", "ong", "ou", "u", "uan", "ue", "un"];
				validCombi["j"] = ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", "u", "uan", "ue", "un"];
				validCombi["x"] = ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", "u", "uan", "ue", "un"];
				validCombi["r"] = ["an", "ang", "ao", "e", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi[""] = ["ao", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "er", "o", "ou"];
				validCombi["f"] = ["an", "ang", "a", "ei", "en", "eng", "o", "ou", "u"];
				validCombi["w"] = ["ai", "an", "ang", "a", "ei", "en", "eng", "o", "u"];

				// verify that there is no typo in validCombi
				/*
				var orderedValidCombi = [
					validCombi["n"], validCombi["l"], validCombi["d"], validCombi["g"], validCombi["h"],
					validCombi["sh"], validCombi["t"], validCombi["zh"], validCombi["m"], validCombi["k"],
					validCombi["ch"], validCombi["p"], validCombi["z"], validCombi["c"], 
					validCombi["b"],  validCombi["s"], validCombi["q"], validCombi["y"], 
					validCombi["j"], validCombi["x"], validCombi["r"], validCombi[""], validCombi["f"], validCombi["w"]
				];
				//console.log(orderedValidCombi.map(function(x) {return x.length;}));
				

				/// typo check 
				var result = true;
				shengmu.forEach(function(x) { 
					//console.log(validCombi[x]); 
					validCombi[x].forEach(function(y) {

						//result = result && yunmu.includes(y);
						//result = result && (yunmu.indexOf(y) != -1);

						if (typeof Array.prototype.includes === "function") { 
						    result = result && yunmu.includes(y);

						} else {
							result = result && (yunmu.indexOf(y) != -1);
						}
					}); 
				});

				// if true no typo in validCombi
				//console.log(result);


				//status.sort(function(a,b) {
				//    return a.val - b.val;
				//});

				yunmuCount = {};

				yunmu.forEach(function(x) { 
					yunmuCount[x] = 0;
					shengmu.forEach(function(y) {
						if (validCombi[y].includes(x))
							yunmuCount[x]++;
					});
				});

				var sortedYunmu = yunmu.sort(function(a, b){ return yunmuCount[b] - yunmuCount[a]; });
				console.log(yunmuCount);
				console.log(sortedYunmu);
				*/
			}

			function cloneObj(obj) {
				return JSON.parse(JSON.stringify(obj));
			}

			// 34 A pos
			// 20 marker width
			//15/30 
			// 90 card width

			function largerDXpair(id) {
				var x1 = avgVertex[id][1][0];
				var x2 = avgVertex[id][2][0];
				var x3 = avgVertex[id][3][0];

				var dx1 = Math.abs(x2 - x1);
				var dx2 = Math.abs(x3 - x2);

				if (dx2 > dx1) return [2, 3];
				else return [1, 2];
			}

			function markerWidth(id) {
				var x1 = avgVertex[id][1][0];
				var x2 = avgVertex[id][2][0];
				var x3 = avgVertex[id][3][0];

				var dx1 = Math.abs(x2 - x1);
				var dx2 = Math.abs(x3 - x2);
				/*
				var y1 = avgVertex[id][1][1];
				var y2 = avgVertex[id][2][1];
				var y3 = avgVertex[id][3][1]; 
				var dy1 = Math.abs(y2 - y1);
				var dy2 = Math.abs(y3 - y2);
				//var dx_min = Math.min(dx1, dx2);
				//var dy_max = Math.max(dy1, dy2);
				//var dy_min = Math.min(dy1, dy2);
				//console.log(dx_max);
				*/
				var dx_max = Math.max(dx1, dx2);
				return dx_max;
			}

			function cloneTransform(src, dest) {
				//var newObj = new THREE.Object3D();
				var pos = src.getWorldPosition();
				var quat = src.getWorldQuaternion();
				//console.log(newObj.matrixAutoUpdate);
				//console.log(pos);

				var parent = src.parent;
				THREE.SceneUtils.detach(dest, dest.parent, scene);

				dest.position.set(pos.x, pos.y, pos.z);
				dest.quaternion.set(quat.x, quat.y, quat.z, quat.w);

				parent.add(dest);
				//console.log(newObj.position);
			}

			function screenSpaceCheck(toneID, yunmuID) {
				if (avgPos[toneID] != undefined && avgPos[yunmuID] != undefined) {// && avgPos[62] != undefined && avgPos[63] != undefined) {
					//console.log(avgVertex[61]);
					var mw = markerWidth(yunmuID);
					var cardWidth = (mw * 1.05) / 20 * 90;
					var cardSixth = cardWidth / 6;
					var markerX = avgPos[toneID][0];

					// dependent on orientation
					var cardLeft = avgPos[yunmuID][0] - cardSixth;
					
					var correctX = toneMarkerTarget[yunmuID];

					var cardproper = cardLeft + ((correctX/90) * cardWidth);
					//var cardproper = cardLeft + ((56/90) * cardWidth);
					var error = Math.abs(cardproper - markerX);
					//console.log(mw);
					//console.log(cardWidth) 
					//console.log(correctX);
					//console.log(cardproper);
					//console.log(markerX)
					const thresh = 3;
					//console.log(error + " " + (error < thresh && error > 0));


					/*
					ctx.strokeStyle = 'black';
					ctx.lineWidth = 2;
					ctx.beginPath();
					ctx.moveTo(cardLeft, 0);
					ctx.lineTo(cardLeft, 640);
					ctx.stroke();

					ctx.strokeStyle = 'red';
					ctx.beginPath();
					ctx.moveTo(cardproper, 0);
					ctx.lineTo(cardproper, 640);
					ctx.stroke();

					ctx.strokeStyle = 'green';
					ctx.lineWidth = 2;
					ctx.beginPath();
					ctx.moveTo(cardLeft + cardWidth, 0);
					ctx.lineTo(cardLeft + cardWidth, 640);
					ctx.stroke();
					*/

					//console.log(cardproper + " " + markerX + " " + error);
					//console.log(cardLeft + " " + cardWidth);

					/*if (error < 3) {
						//console.log("correct");
						ctx.fillStyle = 'green';
						ctx.font = "50px Arial";
						ctx.fillText("correct",320,100);
					}*/

					/* else {
						console.log("wrong");
						ctx.fillStyle = 'red';
						ctx.font = "50px Arial";
						ctx.fillText("wrong",320,100);
					}*/
					return (error < thresh && error > 0);
				}
			}

			// 3d solution

			function space3DCheck() {
				var scene = arScene.scene;
				var anchor = scene.children[2];
				var child2 = anchor.children[1];
				var child3 = anchor.children[2];

				var wp3 = child3.getWorldPosition();
				var child2InChild3Local = child2.worldToLocal(wp3);
				//console.log(child2InChild3Local.x);
				var targetX = ((56 - 15) / 20);
				//console.log(targetX);
				var error = Math.abs(child2InChild3Local.x  - targetX);
				//console.log(error);

				const thresh = 6/20;
				return (error <= thresh)
			}

			function threeDimensionAlternative(toneID, yunmuID) {

				//var check = screenSpaceCheck() || space3DCheck();
				
				/*if (check) {
					console.log("correct");
					ctx.fillStyle = 'green';
					ctx.font = "50px Arial";
					ctx.fillText("correct",320,100);
				} else {
					console.log("wrong");
					ctx.fillStyle = 'red';
					ctx.font = "50px Arial";
					ctx.fillText("wrong",320,100);
				}*/

				function findMarkerRoot(scene, id) {
					if (scene.children == null) return;	
					//var retval = null;
					var retval = scene.children.find(function (child) {
						
						if (child.markerID != undefined) {
							return child.markerID == id;
							//console.log(id + " " + child.markerID);
							//if (child.markerID == id) {
								//retval = child;
								//return child;
							//}
						} else return false;
					});
					return retval;
					//return retval;
				}

				if (avgPos[toneID] == undefined || avgPos[yunmuID] == undefined) return;


				
				 
				var scene = arScene.scene;
				//var anchor = scene.children;
				//console.log(scene);

				//var child2 = anchor.children[1];
				//var child3 = anchor.children[2];

				var yunmuMarker = findMarkerRoot(scene, yunmuID);
				var toneMarker = findMarkerRoot(scene, toneID);

				//console.log(yunmuMarker);
				var worldRot = yunmuMarker.getWorldRotation();
				const rad2deg = (180 / Math.PI);

				var rotVal = worldRot.toVector3().multiplyScalar(rad2deg).z;


				var notMarkerPos = new THREE.Vector2(avgPos[toneID][0], avgPos[toneID][1]);
				//console.log(avgPos[63][0], avgPos[63][1]);
				//console.log(notMarkerPos);
				var projection = 0;
				var dir = null;
				var dirLen = 0;
				var v = null;
				var v1, v2, v3, v4;

				var v0raw = avgVertex[yunmuID][0];
				var v1raw = avgVertex[yunmuID][1];
				var v2raw = avgVertex[yunmuID][2];
				var v3raw = avgVertex[yunmuID][3];

				v0 = new THREE.Vector2(v0raw[0], v0raw[1]);
				v1 = new THREE.Vector2(v1raw[0], v1raw[1]);
				v2 = new THREE.Vector2(v2raw[0], v2raw[1]);
				v3 = new THREE.Vector2(v3raw[0], v3raw[1]);

/*
				console.log(62 + " " + "here");
				console.log(v0raw);
				console.log(v1raw);
				console.log(v2raw);
				console.log(v3raw);

				console.log(63 + " " + "here");
				console.log( avgVertex[63][0]);
				console.log( avgVertex[63][1]);
				console.log( avgVertex[63][2]);
				console.log( avgVertex[63][3]);
*/							

				// do not change the order of if else condition check,
				// (if rotVal > 90 not checked first, rotVal >=0 will need another && rotVal <= 90)
				if (rotVal > 90) { // tilt left
					// 0 1
					dir = v1.sub(v0);
					dirLen = dir.length();
					dirNorm = dir.normalize();

					v = notMarkerPos.sub(v0).divideScalar(dirLen * (9/2));
					projection = v.dot(dir);
				} else if (rotVal >= 0) { // tilt right on hand
					// 1 2
					dir = v2.sub(v1);
					dirLen = dir.length();
					dirNorm = dir.normalize();
					v = notMarkerPos.sub(v1).divideScalar(dirLen * (9/2));
					projection = v.dot(dir);
				} else if (rotVal < -90) {// tilt left upside down
					// 3 4
					dir = v0.sub(v3);
					dirLen = dir.length();
					dirNorm = dir.normalize();
					v = notMarkerPos.sub(v3).divideScalar(dirLen * (9/2));
					projection = v.dot(dir);
				} else if (rotVal < 0) { // tilt right upside down
					// 2 3
					dir = v3.sub(v2);
					dirLen = dir.length();
					dirNorm = dir.normalize();
					v = notMarkerPos.sub(v2).divideScalar(dirLen * (9/2));
					projection = v.dot(dir);
				}

				var correctX = toneMarkerTarget[yunmuID];
				var cardproper = (correctX/90);

				//console.log(cardproper);
				//console.log(projection);

				//console.log(dirLen);
				//console.log(dir);
				//console.log(v);

				// in the ratio of a card len
				var error  = Math.abs(projection - cardproper);
				var thresh = 3/90;

				//console.log(error);
				//console.log("");
				return (error < thresh);
			}
			
			function consoleDebug(markerTracked) {
				var keyList = Object.keys(markerTracked);
				if (keyList.length > 0)
					//console.log(keyList);
					console.log(keyList.length);
			}

			function drawCenterLine(cw, ch) {
				ctx.strokeStyle = 'black';
				ctx.lineWidth = 5;
				ctx.beginPath();
				ctx.moveTo(cw * 0.35, ch * 0.7);
				ctx.lineTo(cw * 0.65, ch * 0.7);
				ctx.stroke();
			}

			function drawCenterText(cw, ch, color, text) {
				if (text == "") return;
				//ctx.fillStyle = "#ff0000";
				ctx.fillStyle = color;
				ctx.font = "80px Hypy";
				var setA = "ABCDE";
				var setB = "FGHIJ";
				var setC = "KLMNO";
				var setD = "PQRST";
				var setE = "UVWXY";
				var setF = "Z_^`~|";
				ctx.fillText(text, cw * 0.35, ch * 0.7);
				//console.log(text);		
				//ctx.fillText("\u00E0", cw * 0.55, ch * 0.7);
			}
			
			function drawMarkerOutline(vertex, pos, color, id) {
				//if (id==-1) id = 99;
				//if (id2==-1) id2 = 99;

				if (id == -1) return;
				ctx.strokeStyle = 'red';
				ctx.lineWidth = 1;
				ctx.beginPath();
				ctx.moveTo(vertex[0][0], vertex[0][1]);
				ctx.lineTo(vertex[1][0], vertex[1][1]);
				ctx.stroke();

				ctx.strokeStyle = 'blue';
				ctx.beginPath();
				ctx.lineTo(vertex[1][0], vertex[1][1]);
				ctx.lineTo(vertex[2][0], vertex[2][1]);
				ctx.stroke();
				ctx.strokeStyle = 'green';

				ctx.beginPath();
				ctx.moveTo(vertex[2][0], vertex[2][1]);
				ctx.lineTo(vertex[3][0], vertex[3][1]);
				ctx.stroke();

				ctx.strokeStyle = 'yellow';
				ctx.beginPath();
				ctx.moveTo(vertex[3][0], vertex[3][1]);
				ctx.lineTo(vertex[0][0], vertex[0][1]);
				ctx.stroke();

				/*
				ctx.beginPath();
				ctx.arc(pos[0], pos[1], 8, 0, Math.PI * 2);
				ctx.fillStyle = color;
				ctx.fill();

				ctx.font = "25px Arial";
				ctx.fillText(id,pos[0],pos[1]);
				*/
			}
			
			function screenTextDisplay(markerTracked) {
				
				function arrContains(ht, obj) {
					//return (ht.indexOf(obj) != -1);
					return (ht[obj] != undefined);
				}
				
				function roundDecPlace(num, dec_place) {
					var modifier = dec_place * 10;
					return Math.round(num * modifier) / modifier;
				}
				
				ctx.font = "25px Arial";
			
			/*
			// combination detection
			if (arrContains(markerTracked, 0) && 
				arrContains(markerTracked, 1) &&
				arrContains(markerTracked, 2)) 
			{
				ctx.fillText("biang2",5,30);
			}*/
			
			// print position on screen for marker 0 and 2 (corresponds to notation marker and tail marker)
			/*
			if (avgPos[61] != null) {
				ctx.fillText(
				roundDecPlace(avgPos[61][0], 2) + "|" + 
				roundDecPlace(avgPos[61][1], 2)
				,5,65);
			}
			
			if (avgPos[62] != null) {
				ctx.fillText(
				roundDecPlace(avgPos[62][0], 2) + "|" + 
				roundDecPlace(avgPos[62][1], 2)
				,5,95);
			}

			if (avgPos[63] != null) {
				ctx.fillText(
				roundDecPlace(avgPos[63][0], 2) + "|" + 
				roundDecPlace(avgPos[63][1], 2)
				,5,125);
			}
			*/
			}
	

	//console.log(sortedYunmu);


	// marker mapping
	// [0 - 3] first 3 used for notation
	// 
	
	
			/*var markerDetectedCount = 0;
			if (avgPos[60] != undefined ) markerDetectedCount++;
			if (avgPos[61] != undefined ) markerDetectedCount++;
			if (avgPos[62] != undefined ) markerDetectedCount++;
			if (avgPos[63] != undefined ) markerDetectedCount++;

			if (markerDetectedCount >= 3) {
				ctx.font = "60px Hypy";
				ctx.fillStyle = "#ff0000";

				var mytext = "ch"+ "\u00ED" + "ang";
				//var mytext2 = "chi"+ "\u00E1" + "ng";
				var mytext3a = "\u02C9";
				var mytext3b = "\u02CA";
				var mytext3 = "chiang";

				var mytext4 = "j"+ "\u00ED" + "ang";
				//var mytext5 = "ji"+ "\u00E1" + "ng";
				var mytext6a = "\u02C9";
				var mytext6b = "\u02CA";
				var mytext6 = "jiang";

				//ctx.fillText("chiang",216,100);
				if (ref1 > 0) {
					if (avgPos[61] != undefined) {
						if (ref1 <= 0.45 && ref2 <= -0.55) {
							ctx.fillText(mytext,215,100);
						}
						else if (ref1 < 0.65 && ref2 < -0.35) {
							ctx.fillStyle = "#00ff00";
							ctx.fillText(mytext3,215,100);
							ctx.fillText(mytext3b,300,100);
						}
						else if (ref1 < 0.875 && ref2 < -0.125) {
							ctx.fillText("chiang",215,100);
						}
						else {
							ctx.fillText("chiang",215,100);
						}
					}
					if (avgPos[60] != undefined) {
						if (ref1 <= 0.45 && ref2 <= -0.55) {
							ctx.fillText(mytext4,215,100);
						}
						else if (ref1 < 0.65 && ref2 < -0.35) {
							ctx.fillStyle = "#00ff00";
							ctx.fillText(mytext6,215,100);
							ctx.fillText(mytext6b,250,100);
						}
						else if (ref1 < 0.875 && ref2 < -0.125) {
							ctx.fillText("jiang",215,100);
						}
						else {
							ctx.fillText("jiang",215,100);
						}
					}
				}
			}*/
			// i 0.35 -0.65
			// a 0.55 -0.45
			// n 0.75 -0.25
			// g 1 0
			
			

			function tick (ctx) {
				arScene.process();
				arScene.renderOn(renderer);
				requestAnimationFrame(function () { 
					tick(ctx); 
				});
				var markerNum = arController.getMarkerNum();
				ctx.clearRect(0,0,canvasWidth,canvasHeight);
				drawCenterLine(canvasWidth, canvasHeight);
				//prevMarkerTracked = markerTracked;
				markerTracked = {};

				yunmuSlot.length = 0;
				shengmuSlot.length = 0;
				toneSlot.length = 0;

				yunmuTextToDisplay = "";
				shengmuTextToDisplay = "";
				
				retireOld(history);
				retireOld2(avgPos);

				for (var i = 0; i<markerNum; i++) {
					var markerInfo = arController.getMarker(i);
					var vertexA = markerInfo.vertex;
					var pos = markerInfo.pos;
					var nativeID = markerInfo.id;
					var id = -1;
					var color = "blue";
					var area = markerInfo.area;
					var newMarkerRecord = null;



					// pattern marker
					/*if (markerInfo.idPatt >= 0 || markerInfo.idMatrix < 0) {
						//markerTracked[markerInfo.idPatt] = markerInfo;
						id = markerInfo.idPatt;
					}

					// matrix marker
					else if (markerInfo.idMatrix >= 0 && markerInfo.idPatt < 0) {
						//markerTracked[markerInfo.idMatrix] = markerInfo;
						id = markerInfo.idMatrix;
					}*/

					if (markerInfo.id >= 0) {
						id = markerInfo.id;
						//console.log(markerInfo);
					}

					if (markerInfo.area > 400 && id != -1) {
						newMarkerRecord = markerRecord(id, pos, vertexA, Date.now(), area);
						markerTracked[markerInfo.idMatrix] = newMarkerRecord;

						if (avgPos[id] == undefined) {
							avgPos[id] = pos.slice();
						} else {
							var newPos = pos.slice();
							var oldPos = avgPos[id];
							var newX = lerp(oldPos[0], newPos[0], 0.6);
							var newY = lerp(oldPos[1], newPos[1], 0.6);
							var lerpedPos = [newX, newY];
							lerpedPos.timestamp = Date.now();
							avgPos[id] = lerpedPos;
						}
						//avgVertex[id] = vertexA.slice();
						avgVertex[id] = cloneObj(vertexA);

						if (id >= 0 && id <= 3) {
							toneSlot.push(markerMapping[id]);
						} else if (id >= 4 && id <= 38) {
							yunmuSlot.push(markerMapping[id]);
						} else if (id >= 39 && id <= 61) {
							shengmuSlot.push(markerMapping[id]);
						}
					}

					if (id >= 0) {
						color = "#00ff00";
					} else {
						color = "#ff0000";
					}
					drawMarkerOutline(vertexA, pos, color, id);

					//if (id >= 0) {
					//	console.log(id + " " + pos );
						//console.log(markerTracked);
					//}
					if (newMarkerRecord != null)
						history.push(newMarkerRecord);

					
				}

				var yunmuTextToDisplay = "";
				var shengmuTextToDisplay = "";

				
				

				if (yunmuSlot.length > 0) {
					yunmuTextToDisplay = yunmuSlot[0];
				}

				if (shengmuSlot.length > 0) {
					shengmuTextToDisplay = shengmuSlot[0];
				}
				var combined = shengmuTextToDisplay.toLowerCase() + yunmuTextToDisplay ;

				var validCheckResult = validCombiCheck(shengmuTextToDisplay.toLowerCase(), yunmuTextToDisplay);
				//console.log(validCheckResult);

				//if (combined != "")
				//	console.log(combined);

				
				//screenTextDisplay(markerTracked);
				//printAvgPos();


				var yunmuID = markerMapping.indexOf(yunmuTextToDisplay);
				var toneID = markerMapping.indexOf(toneSlot[0]);

				if (yunmuID == -1 || toneID == -1)
					return;

				//console.log(yunmuID + " " + toneID);

				if (validCheckResult && (screenSpaceCheck(toneID, yunmuID) || threeDimensionAlternative(toneID, yunmuID)) ) {
					//console.log("correct");
					//ctx.fillStyle = 'green';
					//ctx.font = "50px Arial";
					//ctx.fillText("correct",320,100);
					drawCenterText(640, 480, 'green', combined);
				} else {
					//console.log("wrong");
					//ctx.fillStyle = 'red';
					//ctx.font = "50px Arial";
					//ctx.fillText("wrong",320,100);

					drawCenterText(640, 480, 'red', combined);
				}

				//drawCenterText(640, 480, combined);
			}
		}
	}); // end of get getUserMediaThreeScene

	delete window.ARThreeOnLoad;
};

if (window.ARController && ARController.getUserMediaThreeScene) {
	ARThreeOnLoad();
}
</script>

</body>
</html>