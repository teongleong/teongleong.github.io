<html>
<head>
<title>HYPY</title>
<link rel="shortcut icon" href="#" />
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<style>
html,body {

	margin: 0;
	padding: 0;
	width: 100%;
	text-align: center;
	overflow-x: hidden;
}
.portrait canvas {
	transform-origin: 0 0;
	transform: rotate(-90deg) translateX(-100%);
}
.desktop canvas {
 	transform: scale(1, 1);
}
#myCanvas2 {
	background: rgba(255,255,255,255);
	position: absolute;
	z-index: 1;
	border: 0.1px solid black;
	transform: scale(1, 1);
}

#mainTable {
  position: relative;
  padding: 0px;
}

::-moz-selection{
    background-color:Transparent;
    color:#000;
}

::selection {
	background-color:Transparent;
	color:#000;
}

#sound1 {
	position: absolute;
}

#sound2 {
	position: absolute;
}

@font-face { font-family: Hypy; src: url('fonts/Hypy.ttf'); }

</style>
</head>
<body bgcolor="white">
	<audio id="player"></audio>
	<video id="gum-local" autoplay playsinline hidden></video>
	<table align="center">
		<tr>
			<td id="mainTable">
				<canvas id="myCanvas2"></canvas>
			</td>
		</tr>
	</table>
	<image src="images\sound_inactive.png" id="sound1" hidden> </image>
	<image src="images\sound_active.png" id="sound2" hidden> </image>
	<h1>Hanyu Pinyin</h1>
</body>

<script async src="https://cdn.jsdelivr.net/npm/jsartoolkit@0.0.0/build/artoolkit.min.js"></script>
<script async src="https://cdn.jsdelivr.net/npm/jsartoolkit@0.0.0/examples/js/third_party/three.js/three.min.js"></script>
<script async src="https://cdn.jsdelivr.net/npm/jsartoolkit@0.0.0/js/artoolkit.three.js"></script>

<script>

window.ARThreeOnLoad = function() {

	var scaleX = 1;
	var scaleY = 1;
	var scaleAnchorX = 1;
	var scaleAnchorY = 1;

	var prevSoundName = "";
	var soundName = "";

	// in canvas ratio
	var soundIconPosX = 0.5;
	var soundIconPosY = 0.76;
	var soundIconLength = 0.05;

	var yunmuID = -1;
	var shengmuID = -1;

	var validHistory = [];

	var playPromise;
	var debugSoundList = ["cai1", "cai2", "cai3", "cai4", 
						  "ji1", "ji2", "ji3", "ji4",
						  "zhuang1", "zhuang3", "zhuang4",
						  "guang1", "guang3", "guang4"];

	var validButNoTone = ["zhuang2", "guang2"];

	var stableTest = false;

	function sizeCanvas(canvas, winWidth, winHeight) {
		console.log(winWidth + " " + winHeight);
		if ((winWidth / 640 * 480) > winHeight) {
			
			var finalHeight = winHeight;
			var finalWidth = winHeight / 480 * 640;
			scaleAnchorY = winHeight / 480;
			scaleAnchorX = finalWidth / 640;
			scaleY = 1;
			scaleX = 1.0/480.0*640.0;
			console.log("clamp height "+finalWidth + " " + finalHeight);
			canvas.style.height = finalHeight;
			canvas.style.width = finalWidth;
			//canvas.width = finalWidth;
			//canvas.height = finalHeight;
		} else {
			var finalWidth = winWidth;
			var finalHeight = winWidth / 640 * 480;
			scaleAnchorX = winWidth / 640;
			scaleAnchorY = finalHeight / 480;
			scaleX = 1;
			scaleY = 1.0/640.0*480.0;

			console.log("clamp width "+finalWidth + " " + finalHeight);
			canvas.style.width = finalWidth;
			canvas.style.height = finalHeight;
		}
	}

	function playSound(soundName) {
		if (debugSoundList.indexOf(soundName) == -1) {
			//console.log("playSound: " + soundName + " not on debug list");
			return;
		}
		if (!stableTest) {
			//console.log("playSound: not stable test");
			return; // only play when green (valid)
		}
		var player = document.getElementById("player");
		//console.log(player);
		player.innerHTML = "<source src='sounds/" + soundName + ".mp3' type='audio/mpeg'>";
		//console.log("set innerHTML "+player.innerHTML);
		
		player.load();
		//console.log("player load");
		playPromise = player.play();
 		//console.log("player promise");
		if (playPromise !== undefined) {
		    playPromise.then(_ => {
		      // Automatic playback started!
		      // Show playing UI.
		      // We can now safely pause video...
		      //console.log("success play?");
		      video.pause();
		    })
		    .catch(error => {
		      // Auto-play was prevented
		      // Show paused UI.
		      //console.log("fail play..."+error);
		    });
		}

		//console.log(soundName + " " + testSoundCounter);
		
		/*
		if (player.playing) {
			player.playing = false;
			player.pause();
		}
		player.load();
		player.playing = true;
		player.play();
		player.playing = false;
	*/
	}

	ARController.getUserMediaThreeScene({
		maxARVideoSize: 640,
		cameraParam: 'data/camera.dat',
		onSuccess: function(arScene, arController, arCamera) {
			
			var markerTracked = {};
			//var prevMarkerTracked = {};
			var longTermTracking = {};
			var history = [];
			var avgPos = {};
			var avgVertex = {};

			var renderer = new THREE.WebGLRenderer({antialias: true});

			var cardLen = 1;
			var ref1 = -88;
			var ref2 = -99;
		
			arSetup(arController, renderer);

			var rendererCanvas = renderer.domElement;
			//const width = rendererCanvas.clientWidth;
			//const height = rendererCanvas.clientHeight;  
			//console.log(width + " " + height );
			//console.log(rendererCanvas);

			console.log(window.innerWidth + " " + window.innerHeight);

			sizeCanvas(rendererCanvas, window.innerWidth, window.innerHeight);
			
			var mainTable = document.getElementById("realMainTable");
			var overlay = document.getElementById("myCanvas2");

			overlay.style.width = rendererCanvas.style.width;
			overlay.style.height = rendererCanvas.style.height;

			var ctx = overlay.getContext('2d');
			//ctx.scale(0.5, 0.5);

			
			const width = rendererCanvas.clientWidth;
			const height = rendererCanvas.clientHeight; 

			
			//const width = rendererCanvas.style.width;
			//const height = rendererCanvas.style.height;  
			//overlay.width = window.innerWidth;
			//overlay.height = window.innerHeight;

			overlay.width = width;
			overlay.height = height;

			console.log(width + " " + height);

			var canvasWidth = width;
			var canvasHeight = height;

			//sizeCanvas(overlay, window.innerWidth, window.innerHeight);
			//document.body.onclick = function (e) {console.log("clicked");}
			overlay.onclick = function(e) {
				var rect = overlay.getBoundingClientRect();
				var canvasX = e.clientX - rect.left;
				var canvasY = e.clientY - rect.top;
				//console.log(rect);
				//console.log(canvasX + " " + canvasY);

				var soundIconTrueX = rect.width * soundIconPosX;
				var soundIconTrueY = rect.height * soundIconPosY;
				//console.log(soundIconTrueX + " " + soundIconTrueY);

				var diffX = Math.abs(soundIconTrueX - canvasX);
				var diffY = Math.abs(soundIconTrueY - canvasY);
				var thresh = rect.width * soundIconLength * 0.5;
				if (diffX < thresh && diffY < thresh) {
					if (soundName == "") return;
					//console.log("clicked on sound");
					playSound(soundName);
				}
			};

			var seenMarker = {};
			yunmuSlot = [];
			shengmuSlot = [];
			toneSlot = [];

			var validCombi = [];
			var yunmu = [
				"ai", "an", "ang", "ao", "a", 
				"e", "ei", "en", "eng", "er", 
				"i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", 
				"o", "ong", "ou", 
				"u", "ua", "uai", "uan", "uang", "ue", "ui", "un", "uo", 
				"v", "ve",
				"g"
			];

			var shengmu = [
				"", "b", "c", "ch", "d", "f", "g", "h", "j", "k", "l", "m", 
				"n", "p", "q", "r", "s", "sh", "t", "w", "x", "y", "z", "zh"
			];
			//var validCombiAlt = [];

			const markerMapping = ["tone1", "tone2", "tone3", "tone4",
								"iang", "iong", "uang",
								"ang", "eng", "ong", "uai", "uan", 
								"ian", "iao", "ing", 
								"ia", "ie", "in", "ai", "an", 
								"ao", "ei", "en", "er", "iu",
								"ou", "ua", "ue", "ui", "un", 
								"uo", "ve",  
								"a", "e", "i", "o", "u", "v", "g", // 39
								"b", "c", "ch", "d", "f", "g", "h", "j", "k", "l",
								"m", "n", "p", "q", "r", "s", "sh", "t", "w", "x",
								"y", "z", "zh"];

			const toneMarkerTarget = [-1, -1, -1, -1, 
								66.4, 66.1, 55.5,
								77.6, 78.2, 78.2, 55.5, 55.5, 
								65.6, 65.5, 83.1, 
								66.4, 66.1, 83.1, 77.6, 77.6, 
								77.6, 78.2, 78.2, 78.2, 66.2,
								78.2, 55.5, 56.1, 61.1, 78.2, 
								56.1, 57.8, 
								77,6, 78.2, 83.1, 78.2, 78.2, 78.9, 78.6];
			const yunmuVowelOnSecond = ["ia", "ie", "iu", "ua", 
										"ue", "ui", "uo", "ve", "uai", 
										"iao", "iong", "uan", "uang",
										"ian", "iang"];
			sceneSetup(arScene);
			tick(ctx);
			mappingFunction();

			var marker0;
			var obj3d;
			
			function arSetup(arController, renderer) {
				document.body.className = arController.orientation;
				//arController.setPatternDetectionMode(artoolkit.AR_TEMPLATE_MATCHING_MONO_AND_MATRIX);

				arController.setPatternDetectionMode(artoolkit.AR_MATRIX_CODE_DETECTION);
				//arController.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_4x4_BCH_13_5_5);
				//arController.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_4x4);
				//arController.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_4x4_BCH_13_9_3);
				//arController.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_3x3);

				arController.borderStyle = "white";
				
				// setting renderer size
				
				if (arController.orientation === 'portrait') {
					var w = (window.innerWidth / arController.videoHeight) * arController.videoWidth;
					var h = window.innerWidth;
					renderer.setSize(w, h);
					renderer.domElement.style.paddingBottom = (w-h) + 'px';
				} else {
					if (/Android|mobile|iPad|iPhone/i.test(navigator.userAgent)) {
						renderer.setSize(window.innerWidth, (window.innerWidth / arController.videoWidth) * arController.videoHeight);
					} else {
						renderer.setSize(arController.videoWidth, arController.videoHeight);
						document.body.className += ' desktop';
					}
				}

				// my simple resize test
				//var w = (window.innerWidth / arController.videoHeight) * arController.videoWidth;
				//var h = window.innerWidth;

				/*var h = window.innerHeight;
				var w = window.innerHeight * (arController.videoWidth / arController.videoHeight);
				renderer.setSize(w, h);*/
				
				// add three js renderer to main_table
				var mainTable = document.getElementById("mainTable");
				mainTable.appendChild(renderer.domElement, mainTable);
			}
			
			function sceneSetup(arScene) {
				/*
				var material = new THREE.LineBasicMaterial({ color: 0x0000ff });
				var geometry = new THREE.Geometry();
				geometry.vertices.push(new THREE.Vector3(0, 0, 0));
				geometry.vertices.push(new THREE.Vector3(0, 100, 100));
				geometry.vertices.push(new THREE.Vector3(0, 100, -100));
				var line = new THREE.Line(geometry, material);
				arScene.scene.add(line);
				*/

				var sphere = new THREE.Mesh(
					new THREE.SphereGeometry(0.5, 10, 10),
					new THREE.MeshNormalMaterial()
				);
				sphere.material.shading = THREE.FlatShading;
				sphere.position.z = 1.0;

				var torus = new THREE.Mesh(
					new THREE.TorusGeometry(0.1*2.5, 0.2*2.0, 10, 10),
					new THREE.MeshNormalMaterial()
				);
				torus.material.shading = THREE.FlatShading;
				torus.position.z = 1.25;
				torus.rotation.x = Math.PI/2;
				
				var cube = new THREE.Mesh(
					new THREE.BoxGeometry(1,1,1),
					new THREE.MeshNormalMaterial()
				);
				cube.material.shading = THREE.FlatShading;
				cube.position.z = 0.5;


				//var obj3dRoot = new THREE.Object3D();

				// debug scene with obj3d
				/*obj3d = new THREE.Mesh(
					new THREE.TorusGeometry(0.1*2.5, 0.2*2.0, 10, 10),
					new THREE.MeshNormalMaterial()
				);
				obj3d.material.shading = THREE.FlatShading;
				obj3d.position.z = 20;*/
				//obj3d.rotation.x = Math.PI/2;


				//obj3dRoot.add(obj3d);

				//obj3dRoot.setAngularVelocity(new THREE.Vector3(0, 90, 0));
				//arScene.scene.add(obj3d);

				// create markers with id 0, 1, 2
				// anchor primitive shapes to marker
				//var markerRoot0 = arController.createThreeBarcodeMarker(61);
				//markerRoot0.add(sphere);
				//arScene.scene.add(markerRoot0);

				
				//var markerRoot1 = arController.createThreeBarcodeMarker(62);
				//markerRoot1.add(torus);
				//arScene.scene.add(markerRoot1);
				//marker0 = markerRoot1;
				
				//var markerRoot2 = arController.createThreeBarcodeMarker(63);
				//markerRoot2.add(cube);
				//arScene.scene.add(markerRoot2);

				//test obj root 
				
				/*
				testObj = new THREE.Object3D();
				
				testObj.add(markerRoot0);
				testObj.add(markerRoot1);
				testObj.add(markerRoot2);
				//arScene.scene.add(testObj);

				var clone1 = new THREE.Object3D();
				var clone2 = new THREE.Object3D();
				var clone3 = new THREE.Object3D();

				testObj.add(clone1);
				testObj.add(clone2);
				testObj.add(clone3);
				*/

				for(var i=0; i<62; i++) {
					var markerRoot = arController.createThreeBarcodeMarker(i);
					markerRoot.markerID = i;
					arScene.scene.add(markerRoot);
				}
			}

			function markerRecord(id, pos, vertex, timestamp, area) {
				var retval = [];
				retval.id = id;
				retval.pos = pos.slice();
				retval.vertex = cloneObj(vertex);
				retval.timestamp = timestamp;
				retval.area = area;
				return retval;
			}

			function shiftToLength(arr, len) {
				while(arr.length > len) {
					arr.shift();
				}
				return arr;
			}

			function percentValid(validHistory) {
				if (validHistory.length == 0) return 0;
				var validCount = 0;
				validHistory.forEach(function(b) {if (b) validCount++});
				var percent = validCount / validHistory.length;
				//console.log((percent * 100)+ " percent valid here ");
				return percent;
			}

			function retireOld(history) {
				var stopFlag = false;
				while (history.length > 0 && !stopFlag) {
					var elapsed = Date.now() - history[0].timestamp;
					if (elapsed > 2000) {
						history.shift();
					} else {
						stopFlag = true;
					}
				}
			}

			function retireOld2(avgPos) {
				//console.log(Object.keys(avgPos).length);
				Object.keys(avgPos).forEach(function(key) {
			        var apos = avgPos[key];

			        if (apos == undefined)
			        	return;

			        var elapsed = Date.now() - apos.timestamp;

			        if (elapsed > 2000) {
						avgPos[key] = undefined;
					} else {
						stopFlag = true;
					}
			    });
			}

			function lerp(a, b, f)
			{
			    return a + f * (b - a);
			}

			function toUTF16(codePoint) {
			    var TEN_BITS = parseInt('1111111111', 2);
			    function u(codeUnit) {
			        return '\\u'+codeUnit.toString(16).toUpperCase();
			    }

			    if (codePoint <= 0xFFFF) {
			        return u(codePoint);
			    }
			    codePoint -= 0x10000;

			    // Shift right to get to most significant 10 bits
			    var leadSurrogate = 0xD800 + (codePoint >> 10);

			    // Mask to get least significant 10 bits
			    var tailSurrogate = 0xDC00 + (codePoint & TEN_BITS);

			    return u(leadSurrogate) + u(tailSurrogate);
			}

			function validCombiCheck(shengmuText, yunmuText) {
				var arr = validCombi[shengmuText];
				if (arr == undefined) return false;
				return (arr.indexOf(yunmuText) != -1);
			}

			function mappingFunction() {

				validCombi["n"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "g", "ian", "iang", "iao", "ie", "in", "ing", "iu", "ong", "ou", "u", "uan", "un", "uo", "v", "ve"];
				validCombi["l"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "eng", "i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iu", "ong", "ou", "u", "uan","un", "uo", "v", "ve"];
				validCombi["d"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ia", "ian", "iao", "ie", "ing", "iu", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["g"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["h"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["sh"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["t"] = ["ai", "an", "ang", "ao", "a", "e", "eng", "i", "ian", "iao", "ie", "ing", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["zh"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "ua", "uai", "uang", "ui", "un", "uo"];
				validCombi["m"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "iu", "o", "ou", "u"];
				validCombi["k"] = ["ai", "an", "ang", "ao", "a", "e", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["ch"] = ["ai", "an", "ang", "ao", "a", "e", "eng", "i", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["p"] = ["ai", "an", "ang", "ao", "a", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "o", "ou", "u"];
				validCombi["z"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["c"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["b"] = ["ai", "an", "ang", "ao", "a", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "o", "u"];
				validCombi["s"] = ["ai", "an", "ang", "ao", "a", "e", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["q"] = ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iang", "iong", "iu", "u", "uan", "ue", "un"];
				validCombi["y"] = ["an", "ang", "ao", "a", "e", "i", "in", "ing", "o", "ong", "ou", "u", "uan", "ue", "un"];
				validCombi["j"] = ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", "u", "uan", "ue", "un"];
				validCombi["x"] = ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", "u", "uan", "ue", "un"];
				validCombi["r"] = ["an", "ang", "ao", "e", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi[""] = ["ao", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "er", "o", "ou"];
				validCombi["f"] = ["an", "ang", "a", "ei", "en", "eng", "o", "ou", "u"];
				validCombi["w"] = ["ai", "an", "ang", "a", "ei", "en", "eng", "o", "u"];

				// verify that there is no typo in validCombi
				/*
				var orderedValidCombi = [
					validCombi["n"], validCombi["l"], validCombi["d"], validCombi["g"], validCombi["h"],
					validCombi["sh"], validCombi["t"], validCombi["zh"], validCombi["m"], validCombi["k"],
					validCombi["ch"], validCombi["p"], validCombi["z"], validCombi["c"], 
					validCombi["b"],  validCombi["s"], validCombi["q"], validCombi["y"], 
					validCombi["j"], validCombi["x"], validCombi["r"], validCombi[""], validCombi["f"], validCombi["w"]
				];
				//console.log(orderedValidCombi.map(function(x) {return x.length;}));
				

				/// typo check 
				var result = true;
				shengmu.forEach(function(x) { 
					//console.log(validCombi[x]); 
					validCombi[x].forEach(function(y) {

						//result = result && yunmu.includes(y);
						//result = result && (yunmu.indexOf(y) != -1);

						if (typeof Array.prototype.includes === "function") { 
						    result = result && yunmu.includes(y);

						} else {
							result = result && (yunmu.indexOf(y) != -1);
						}
					}); 
				});

				// if true no typo in validCombi
				//console.log(result);


				//status.sort(function(a,b) {
				//    return a.val - b.val;
				//});

				yunmuCount = {};

				yunmu.forEach(function(x) { 
					yunmuCount[x] = 0;
					shengmu.forEach(function(y) {
						if (validCombi[y].includes(x))
							yunmuCount[x]++;
					});
				});

				var sortedYunmu = yunmu.sort(function(a, b){ return yunmuCount[b] - yunmuCount[a]; });
				console.log(yunmuCount);
				console.log(sortedYunmu);
				*/
			}

			function cloneObj(obj) {
				return JSON.parse(JSON.stringify(obj));
			}

			// 34 A pos
			// 20 marker width
			//15/30 
			// 90 card width

			function largerDXpair(id) {
				var x1 = avgVertex[id][1][0];
				var x2 = avgVertex[id][2][0];
				var x3 = avgVertex[id][3][0];

				var dx1 = Math.abs(x2 - x1);
				var dx2 = Math.abs(x3 - x2);

				if (dx2 > dx1) return [2, 3];
				else return [1, 2];
			}

			function markerWidth(id) {
				var x1 = avgVertex[id][1][0];
				var x2 = avgVertex[id][2][0];
				var x3 = avgVertex[id][3][0];

				var dx1 = Math.abs(x2 - x1);
				var dx2 = Math.abs(x3 - x2);
				/*
				var y1 = avgVertex[id][1][1];
				var y2 = avgVertex[id][2][1];
				var y3 = avgVertex[id][3][1]; 
				var dy1 = Math.abs(y2 - y1);
				var dy2 = Math.abs(y3 - y2);
				//var dx_min = Math.min(dx1, dx2);
				//var dy_max = Math.max(dy1, dy2);
				//var dy_min = Math.min(dy1, dy2);
				//console.log(dx_max);
				*/
				var dx_max = Math.max(dx1, dx2);
				return dx_max;
			}

			function cloneTransform(src, dest) {
				//var newObj = new THREE.Object3D();
				var pos = src.getWorldPosition();
				var quat = src.getWorldQuaternion();
				//console.log(newObj.matrixAutoUpdate);
				//console.log(pos);

				var parent = src.parent;
				THREE.SceneUtils.detach(dest, dest.parent, scene);

				dest.position.set(pos.x, pos.y, pos.z);
				dest.quaternion.set(quat.x, quat.y, quat.z, quat.w);

				parent.add(dest);
				//console.log(newObj.position);
			}

			function screenSpaceCheck(toneID, yunmuID) {
				if (avgPos[toneID] != undefined && avgPos[yunmuID] != undefined) {// && avgPos[62] != undefined && avgPos[63] != undefined) {
					//console.log(avgVertex[61]);
					var mw = markerWidth(yunmuID);
					var mw2 = markerWidth(toneID);

					mw = (mw + mw2) / 2;
					var cardWidth = (mw * 1.00) / 20 * 90;
					var cardSixth = cardWidth / 6;
					var markerX = avgPos[toneID][0];

					// dependent on orientation
					var cardLeft = avgPos[yunmuID][0] - cardSixth;
					
					var correctX = toneMarkerTarget[yunmuID];

					var cardproper = cardLeft + ((correctX/90) * cardWidth);
					//var cardproper = cardLeft + ((56/90) * cardWidth);
					var error = Math.abs(cardproper - markerX);
					const thresh = 7;
					
					
					ctx.strokeStyle = 'black';
					ctx.lineWidth = 2;
					ctx.beginPath();
					ctx.moveTo(cardLeft * scaleAnchorX, 0);
					ctx.lineTo(cardLeft * scaleAnchorX, 640);
					ctx.stroke();

					ctx.strokeStyle = 'red';
					ctx.beginPath();
					ctx.moveTo(cardproper * scaleAnchorX, 0);
					ctx.lineTo(cardproper * scaleAnchorX, 640);
					ctx.stroke();

					ctx.strokeStyle = 'green';
					ctx.lineWidth = 2;
					ctx.beginPath();
					ctx.moveTo((cardLeft + cardWidth) * scaleAnchorX, 0);
					ctx.lineTo((cardLeft + cardWidth)  * scaleAnchorX, 640);
					ctx.stroke();
					

					console.log(cardproper + " " + markerX + " " + error);
					//console.log(cardLeft + " " + cardWidth);

					/*if (error < 3) {
						//console.log("correct");
						ctx.fillStyle = 'green';
						ctx.font = "50px Arial";
						ctx.fillText("correct",320,100);
					}*/

					/* else {
						console.log("wrong");
						ctx.fillStyle = 'red';
						ctx.font = "50px Arial";
						ctx.fillText("wrong",320,100);
					}*/
					return (error < thresh && error > 0);
				}
			}

			// 3d solution

			function space3DCheck() {
				var scene = arScene.scene;
				var anchor = scene.children[2];
				var child2 = anchor.children[1];
				var child3 = anchor.children[2];

				var wp3 = child3.getWorldPosition();
				var child2InChild3Local = child2.worldToLocal(wp3);
				//console.log(child2InChild3Local.x);
				var targetX = ((56 - 15) / 20);
				//console.log(targetX);
				var error = Math.abs(child2InChild3Local.x  - targetX);
				//console.log(error);

				const thresh = 6/20;
				return (error <= thresh)
			}



			// pinyin is the string to change, vowelIndex 0 for first vowel, 1 for second, 2 for third
			// tone 1 2 3 4
			function markTheVowel(pinyin, vowelIndex, tone) {

				//  a i o e u
				const setA = "ABCDE";
				const setB = "FGHIJ";
				const setC = "KLMNO";
				const setD = "PQRST";
				const setE = "UVWXY";
				const setF = "Z_^`~|";

				var tokenized = [];
				//var vowelFiltered = "";
				tokenized = pinyin.split("");
				var vowelFiltered = tokenized.filter(c => (c == "a" || c == "e" || c == "i" || c == "o" || c == "u" || c == "v"));

				if (pinyin == "") return "";
				//console.log(vowelFiltered + " " + vowelFiltered.length);
				if (vowelIndex >= vowelFiltered.length) {
					console.log("markTheVowel invalid vowelIndex");
					return pinyin;
				}

				var targetVowel = vowelFiltered[vowelIndex];

				var setChosen = "";
				if (targetVowel == "a") setChosen = setA;
				else if (targetVowel == "i") setChosen = setB;
				else if (targetVowel == "o") setChosen = setC;
				else if (targetVowel == "e") setChosen = setD;
				else if (targetVowel == "u") setChosen = setE;

				return pinyin.replace(targetVowel, setChosen[tone-1]);
				//return setA + setB + setC + setD + setE + setF;

			}

			function threeDimensionAlternative(toneID, yunmuID) {

				//var check = screenSpaceCheck() || space3DCheck();
				
				/*if (check) {
					console.log("correct");
					ctx.fillStyle = 'green';
					ctx.font = "50px Arial";
					ctx.fillText("correct",320,100);
				} else {
					console.log("wrong");
					ctx.fillStyle = 'red';
					ctx.font = "50px Arial";
					ctx.fillText("wrong",320,100);
				}*/

				function findMarkerRoot(scene, id) {
					if (scene.children == null) return;	
					//var retval = null;
					var retval = scene.children.find(function (child) {
						
						if (child.markerID != undefined) {
							return child.markerID == id;
							//console.log(id + " " + child.markerID);
							//if (child.markerID == id) {
								//retval = child;
								//return child;
							//}
						} else return false;
					});
					return retval;
					//return retval;
				}

				if (avgPos[toneID] == undefined || avgPos[yunmuID] == undefined) return;


				
				 
				var scene = arScene.scene;
				//var anchor = scene.children;
				//console.log(scene);

				//var child2 = anchor.children[1];
				//var child3 = anchor.children[2];

				var yunmuMarker = findMarkerRoot(scene, yunmuID);
				var toneMarker = findMarkerRoot(scene, toneID);

				//console.log(yunmuMarker);
				var worldRot = yunmuMarker.getWorldRotation();
				const rad2deg = (180 / Math.PI);

				var rotVal = worldRot.toVector3().multiplyScalar(rad2deg).z;


				var notMarkerPos = new THREE.Vector2(avgPos[toneID][0], avgPos[toneID][1]);
				//console.log(avgPos[63][0], avgPos[63][1]);
				//console.log(notMarkerPos);
				var projection = 0;
				var dir = null;
				var dirLen = 0;
				var v = null;
				var v1, v2, v3, v4;

				var v0raw = avgVertex[yunmuID][0];
				var v1raw = avgVertex[yunmuID][1];
				var v2raw = avgVertex[yunmuID][2];
				var v3raw = avgVertex[yunmuID][3];

				v0 = new THREE.Vector2(v0raw[0], v0raw[1]);
				v1 = new THREE.Vector2(v1raw[0], v1raw[1]);
				v2 = new THREE.Vector2(v2raw[0], v2raw[1]);
				v3 = new THREE.Vector2(v3raw[0], v3raw[1]);

/*
				console.log(62 + " " + "here");
				console.log(v0raw);
				console.log(v1raw);
				console.log(v2raw);
				console.log(v3raw);

				console.log(63 + " " + "here");
				console.log( avgVertex[63][0]);
				console.log( avgVertex[63][1]);
				console.log( avgVertex[63][2]);
				console.log( avgVertex[63][3]);
*/							

				// do not change the order of if else condition check,
				// (if rotVal > 90 not checked first, rotVal >=0 will need another && rotVal <= 90)
				if (rotVal > 90) { // tilt left
					// 0 1
					dir = v1.sub(v0);
					dirLen = dir.length();
					dirNorm = dir.normalize();

					v = notMarkerPos.sub(v0).divideScalar(dirLen * (9/2));
					projection = v.dot(dir);
				} else if (rotVal >= 0) { // tilt right on hand
					// 1 2
					dir = v2.sub(v1);
					dirLen = dir.length();
					dirNorm = dir.normalize();
					v = notMarkerPos.sub(v1).divideScalar(dirLen * (9/2));
					projection = v.dot(dir);
				} else if (rotVal < -90) {// tilt left upside down
					// 3 4
					dir = v0.sub(v3);
					dirLen = dir.length();
					dirNorm = dir.normalize();
					v = notMarkerPos.sub(v3).divideScalar(dirLen * (9/2));
					projection = v.dot(dir);
				} else if (rotVal < 0) { // tilt right upside down
					// 2 3
					dir = v3.sub(v2);
					dirLen = dir.length();
					dirNorm = dir.normalize();
					v = notMarkerPos.sub(v2).divideScalar(dirLen * (9/2));
					projection = v.dot(dir);
				}

				var correctX = toneMarkerTarget[yunmuID];
				var cardproper = (correctX/90);

				//console.log(cardproper);
				//console.log(projection);

				//console.log(dirLen);
				//console.log(dir);
				//console.log(v);

				// in the ratio of a card len
				var error  = Math.abs(projection - cardproper);
				var thresh = 10/90;
				//console.log(error);

				//console.log("");
				return (error < thresh);
			}
			
			function consoleDebug(markerTracked) {
				var keyList = Object.keys(markerTracked);
				if (keyList.length > 0)
					//console.log(keyList);
					console.log(keyList.length);
			}

			function drawSoundIcon(cw, ch) {
				var img=document.getElementById("sound1");
				ctx.drawImage(img, 
					cw * (soundIconPosX - soundIconLength*0.5), 
					ch * (soundIconPosY - soundIconLength*0.5), 
					cw*soundIconLength, 
					cw*((soundIconLength / 70) * 53));
			}

			function drawSoundIcon2(cw, ch) {
				var img=document.getElementById("sound2");
				ctx.drawImage(img, 
					cw * (soundIconPosX - soundIconLength*0.5), 
					ch * (soundIconPosY - soundIconLength*0.5), 
					cw*soundIconLength, 
					cw*((soundIconLength / 70) * 53));
			}

			function drawCenterLine(cw, ch) {
				ctx.strokeStyle = 'DimGrey';
				ctx.lineWidth = 2;
				ctx.beginPath();
				ctx.moveTo(cw * 0.35, ch * 0.7);
				ctx.lineTo(cw * 0.65, ch * 0.7);
				ctx.stroke();
			}

			function drawCenterText(cw, ch, color, text) {
				if (text == "") return;
				//ctx.fillStyle = "#ff0000";
				ctx.fillStyle = color;
				var fontSize = 75 * scaleAnchorX
				ctx.font = fontSize+"px Hypy";
				var setA = "ABCDE";
				var setB = "FGHIJ";
				var setC = "KLMNO";
				var setD = "PQRST";
				var setE = "UVWXY";
				var setF = "Z_^`~|";
				ctx.fillText(text, cw * 0.35, ch * 0.7);
				//console.log(text);		
				//ctx.fillText("\u00E0", cw * 0.55, ch * 0.7);
			}
			
			function drawMarkerOutline(vertex, pos, color, id) {
				//if (id==-1) id = 99;
				//if (id2==-1) id2 = 99;
				//console.log(scaleX + " " + scaleY + " " + scaleAnchorX);
				if (id == -1) return;
				ctx.strokeStyle = 'red';
				ctx.lineWidth = 1;
				ctx.beginPath();
				ctx.moveTo(vertex[0][0]*scaleAnchorX, vertex[0][1]*scaleAnchorY);
				ctx.lineTo(vertex[1][0]*scaleAnchorX, vertex[1][1]*scaleAnchorY);
				ctx.stroke();

				ctx.strokeStyle = 'blue';
				ctx.beginPath();
				ctx.lineTo(vertex[1][0]*scaleAnchorX, vertex[1][1]*scaleAnchorY);
				ctx.lineTo(vertex[2][0]*scaleAnchorX, vertex[2][1]*scaleAnchorY);
				ctx.stroke();
				ctx.strokeStyle = 'green';

				ctx.beginPath();
				ctx.moveTo(vertex[2][0]*scaleAnchorX, vertex[2][1]*scaleAnchorY);
				ctx.lineTo(vertex[3][0]*scaleAnchorX, vertex[3][1]*scaleAnchorY);
				ctx.stroke();

				ctx.strokeStyle = 'yellow';
				ctx.beginPath();
				ctx.moveTo(vertex[3][0]*scaleAnchorX, vertex[3][1]*scaleAnchorY);
				ctx.lineTo(vertex[0][0]*scaleAnchorX, vertex[0][1]*scaleAnchorY);
				ctx.stroke();
				/*
				ctx.beginPath();
				ctx.arc(pos[0], pos[1], 8, 0, Math.PI * 2);
				ctx.fillStyle = color;
				ctx.fill();

				ctx.font = "25px Arial";
				ctx.fillText(id,pos[0],pos[1]);
				*/
			}			

			function tick (ctx) {
				arScene.process();
				arScene.renderOn(renderer);
				requestAnimationFrame(function () { 
					tick(ctx); 
				});
				var markerNum = arController.getMarkerNum();
				ctx.clearRect(0,0,canvasWidth,canvasHeight);
				drawCenterLine(canvasWidth, canvasHeight);
				drawSoundIcon(canvasWidth, canvasHeight);
				//prevMarkerTracked = markerTracked;
				markerTracked = {};

				yunmuSlot.length = 0;
				shengmuSlot.length = 0;
				toneSlot.length = 0;

				yunmuText = "";
				shengmuText = "";
				soundName = "";
				
				retireOld(history);
				retireOld2(avgPos);

				for (var i = 0; i<markerNum; i++) {
					var markerInfo = arController.getMarker(i);
					var vertex = markerInfo.vertex;
					var pos = markerInfo.pos;
					var id = markerInfo.id;
					var color = "blue";
					var area = markerInfo.area;
					var newMarkerRecord = null;

					if (id != -1) {
						newMarkerRecord = markerRecord(id, pos, vertex, Date.now(), area);
						markerTracked[id] = newMarkerRecord;

						// lerping position 
						/*if (avgPos[id] == undefined) {
							avgPos[id] = pos.slice();
						} else {
							var newPos = pos.slice();
							var oldPos = avgPos[id];
							var newX = lerp(oldPos[0], newPos[0], 0.6);
							var newY = lerp(oldPos[1], newPos[1], 0.6);
							var lerpedPos = [newX, newY];
							lerpedPos.timestamp = Date.now();
							avgPos[id] = lerpedPos;
						}*/

						// TODO eventually i need to do some kind of moving window average
						avgPos[id] = pos.slice();
						avgVertex[id] = cloneObj(vertex);

						// categorizing markers into 3 types
						if (id >= 0 && id <= 3) {
							toneSlot.push(id);
						} else if (id >= 4 && id <= 38) {
							yunmuSlot.push(id);
						} else if (id >= 39 && id <= 61) {
							shengmuSlot.push(id);
						}
					}

					if (id >= 0) {
						color = "#00ff00";
					} else {
						color = "#ff0000";
					}
					//drawMarkerOutline(vertex, pos, color, id);

					if (newMarkerRecord != null)
						history.push(newMarkerRecord);
				}

				// exit if there are duplicate yunmu or shengmu or tone
				if (yunmuSlot.length > 1) {
					console.log("duplicate yunmu "+yunmuSlot);
					return;
				}
				if (shengmuSlot.length > 1) {
					console.log("duplicate shengmu "+shengmuSlot);
					return;
				}
				if (toneSlot.length > 1) {
					console.log("duplicate tone "+toneSlot);
					return;	
				}

				var shengmuText = (shengmuSlot.length > 0) ? markerMapping[shengmuSlot[0]] : "";
				var yunmuText = (yunmuSlot.length > 0) ? markerMapping[yunmuSlot[0]] : "";

				//yunmuID = markerMapping.indexOf(yunmuText);
				//shengmuID = markerMapping.indexOf(shengmuText);;
				shengmuID = (shengmuSlot.length > 0) ? shengmuSlot[0] : -1;
				yunmuID = (yunmuSlot.length > 0) ? yunmuSlot[0] : -1;

				var leftText = "";
				var rightText = "";

				if (yunmuID != -1 && shengmuID != -1) { // both components are there
					var yposX = markerTracked[yunmuID].pos[0];
					var sposX = markerTracked[shengmuID].pos[0];
					leftText = (sposX < yposX) ? yunmuText : shengmuText;
					rightText = (sposX < yposX) ? shengmuText : yunmuText;
				} else { // either one of them missing or both
					leftText = shengmuText;
					rightText = yunmuText;
				}

				//for debug
				//console.log(threeDimensionAlternative(toneID, yunmuID));
				//console.log(screenSpaceCheck(toneID, yunmuID));

				var combined = leftText + rightText ;
				
				var validCheckResult = validCombiCheck(shengmuText, yunmuText);

				var toneID = (toneSlot.length > 0) ? toneSlot[0] : -1;;
				if (!validCheckResult || (toneID == -1)) {
					drawCenterText(width, height, 'black', combined);
					return;
				}

				// a small set of yunmu has notation on the second
				var vowelIndex = (yunmuVowelOnSecond.indexOf(yunmuText) != -1) ? 1 : 0;
				var markedPinyin = markTheVowel(combined, vowelIndex, toneID + 1);

				//var simpleTest = screenSpaceCheck(toneID, yunmuID);
				var complicatedTest = threeDimensionAlternative(toneID, yunmuID);
				
				validHistory.push(complicatedTest);
				shiftToLength(validHistory, 60);
				

				stableTest = (percentValid(validHistory) > 0.5);
				

				//var tonePosCheck = (simpleTest || complicatedTest);

				var toneName = (toneID + 1);
				if (isNaN(toneName)) return;
				soundName = combined + toneName;

				var noToneTest = (validButNoTone.indexOf(soundName) != -1);

				if (stableTest && !noToneTest) drawSoundIcon2(canvasWidth, canvasHeight);
				if (prevSoundName != soundName  && stableTest && !noToneTest) {
					console.log(soundName);
					playSound(soundName);
					prevSoundName = soundName;
				}

				var color = (stableTest && !noToneTest) ? 'green' : 'red';
				var textDisplay = (stableTest && !noToneTest) ? markedPinyin : combined;
				drawCenterText(width, height, color, textDisplay);

			}
		}
	}); // end of get getUserMediaThreeScene

	delete window.ARThreeOnLoad;
};

if (window.ARController && ARController.getUserMediaThreeScene) {
	ARThreeOnLoad();
}
</script>
</html>