<html>
<head>
<title>HYPY</title>
<link rel="shortcut icon" href="#" />
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<style>
html,body {
	margin: 0;
	padding: 0;
	width: 100%;
	text-align: center;
	overflow-x: hidden;
}
.portrait canvas {
	transform-origin: 0 0;
	transform: rotate(-90deg) translateX(-100%);
}
.desktop canvas {
 	transform: scale(1, 1);
}
#myCanvas2 {
	background: rgba(0,0,0,0.0);
	position: absolute;
	z-index: 1;
	border: 1px solid black;
	border-width: 2px;
	border-style: groove;
	transform: scale(1, 1);
}

#mainTable {
  position: relative;
  padding: 8px;
}

@font-face { font-family: Hypy; src: url('fonts/Hypy.ttf'); }



</style>
</head>
<body bgcolor="white">
<table align="center">
<tr><td id="mainTable">
<canvas id="myCanvas2"></canvas>
</td></tr>
<video id="gum-local" autoplay playsinline hidden></video>
</table>
<h1>Hanyu Pinyin</h1>

<script async src="js/artoolkit.demin.js"></script>
<script async src="https://cdn.jsdelivr.net/npm/jsartoolkit@0.0.0/examples/js/third_party/three.js/three.min.js"></script>
<script async src="js/artoolkit.three.js"></script>

<script>

window.ARThreeOnLoad = function() {

	ARController.getUserMediaThreeScene({
		maxARVideoSize: 640,
		cameraParam: 'data/camera.dat',
		onSuccess: function(arScene, arController, arCamera) {
			
			var markerTracked = {};
			var prevMarkerTracked = {};
			var longTermTracking = {};
			var history = [];
			var avgPos = {};
			var avgVertex = {};

			
			var renderer = new THREE.WebGLRenderer({antialias: true});

			var cardLen = 1;
			var ref1 = -88;
			var ref2 = -99;
		

			arSetup(arController, renderer);
			
			const rendererCanvas = renderer.domElement;
			const width = rendererCanvas.clientWidth;
			const height = rendererCanvas.clientHeight;  
			console.log(width + " " + height );

			var overlay = document.getElementById("myCanvas2");
			var ctx = overlay.getContext('2d');
			//ctx.scale(0.5, 0.5);

			overlay.width = width;
			overlay.height = height;
			var canvasWidth = width;
			var canvasHeight = height;

			sceneSetup(arScene);
			tick(ctx);
			mappingFunction();

			var marker0;
			var obj3d;
			
			function arSetup(arController, renderer) {
				document.body.className = arController.orientation;
				//arController.setPatternDetectionMode(artoolkit.AR_TEMPLATE_MATCHING_MONO_AND_MATRIX);

				arController.setPatternDetectionMode(artoolkit.AR_MATRIX_CODE_DETECTION);
				//arController.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_4x4_BCH_13_5_5);
				//arController.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_4x4);
				//arController.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_4x4_BCH_13_9_3);

				//arController.setMatrixCodeType(artoolkit.AR_MATRIX_CODE_3x3);
				arController.borderStyle = "white";
				
				// setting renderer size
				
				if (arController.orientation === 'portrait') {
					var w = (window.innerWidth / arController.videoHeight) * arController.videoWidth;
					var h = window.innerWidth;
					renderer.setSize(w, h);
					renderer.domElement.style.paddingBottom = (w-h) + 'px';
				} else {
					if (/Android|mobile|iPad|iPhone/i.test(navigator.userAgent)) {
						renderer.setSize(window.innerWidth, (window.innerWidth / arController.videoWidth) * arController.videoHeight);
					} else {
						renderer.setSize(arController.videoWidth, arController.videoHeight);
						document.body.className += ' desktop';
					}
				}

				// my simple resize test
				//var w = (window.innerWidth / arController.videoHeight) * arController.videoWidth;
				//var h = window.innerWidth;

				/*var h = window.innerHeight;
				var w = window.innerHeight * (arController.videoWidth / arController.videoHeight);
				renderer.setSize(w, h);*/
				
				// add three js renderer to main_table
				var mainTable = document.getElementById("mainTable");
				mainTable.appendChild(renderer.domElement, mainTable);
			}
			
			function sceneSetup(arScene) {
				/*
				var material = new THREE.LineBasicMaterial({ color: 0x0000ff });
				var geometry = new THREE.Geometry();
				geometry.vertices.push(new THREE.Vector3(0, 0, 0));
				geometry.vertices.push(new THREE.Vector3(0, 100, 100));
				geometry.vertices.push(new THREE.Vector3(0, 100, -100));
				var line = new THREE.Line(geometry, material);
				arScene.scene.add(line);
				*/

				var sphere = new THREE.Mesh(
					new THREE.SphereGeometry(0.5, 10, 10),
					new THREE.MeshNormalMaterial()
				);
				sphere.material.shading = THREE.FlatShading;
				sphere.position.z = 1.0;

				var torus = new THREE.Mesh(
					new THREE.TorusGeometry(0.1*2.5, 0.2*2.0, 10, 10),
					new THREE.MeshNormalMaterial()
				);
				torus.material.shading = THREE.FlatShading;
				torus.position.z = 1.25;
				torus.rotation.x = Math.PI/2;
				
				var cube = new THREE.Mesh(
					new THREE.BoxGeometry(1,1,1),
					new THREE.MeshNormalMaterial()
				);
				cube.material.shading = THREE.FlatShading;
				cube.position.z = 0.5;


				//var obj3dRoot = new THREE.Object3D();

				// debug scene with obj3d
				obj3d = new THREE.Mesh(
					new THREE.TorusGeometry(0.1*2.5, 0.2*2.0, 10, 10),
					new THREE.MeshNormalMaterial()
				);
				obj3d.material.shading = THREE.FlatShading;
				obj3d.position.z = 20;
				//obj3d.rotation.x = Math.PI/2;


				//obj3dRoot.add(obj3d);

				//obj3dRoot.setAngularVelocity(new THREE.Vector3(0, 90, 0));
				arScene.scene.add(obj3d);

				// create markers with id 0, 1, 2
				// anchor primitive shapes to marker
				var markerRoot0 = arController.createThreeBarcodeMarker(61);
				markerRoot0.add(sphere);
				//arScene.scene.add(markerRoot0);

				
				var markerRoot1 = arController.createThreeBarcodeMarker(62);
				markerRoot1.add(torus);
				//arScene.scene.add(markerRoot1);
				marker0 = markerRoot1;
				
				var markerRoot2 = arController.createThreeBarcodeMarker(63);
				markerRoot2.add(cube);
				//arScene.scene.add(markerRoot2);

				//test obj root 

				testObj = new THREE.Object3D();
				
				testObj.add(markerRoot0);
				testObj.add(markerRoot1);
				testObj.add(markerRoot2);
				arScene.scene.add(testObj);

				var clone1 = new THREE.Object3D();
				var clone2 = new THREE.Object3D();
				var clone3 = new THREE.Object3D();

				testObj.add(clone1);
				testObj.add(clone2);
				testObj.add(clone3);


				/*arController.loadMarker('data/patt1.patt', function(markerId) {
					var markerRoot = arController.createThreeMarker(markerId, 3);
					markerRoot.add(torus);
					arScene.scene.add(markerRoot);
					console.log("markerID? "+markerId);
				});

				arController.loadMarker('data/patt15.patt', function(markerId) {
					var markerRoot = arController.createThreeMarker(markerId, 3);
					markerRoot.add(sphere);
					arScene.scene.add(markerRoot);
					console.log("markerID? "+markerId);
				});

				arController.loadMarker('data/patt51.patt', function(markerId) {
					var markerRoot = arController.createThreeMarker(markerId, 3);
					markerRoot.add(cube);
					arScene.scene.add(markerRoot);
					console.log("markerID? "+markerId);
				});

				arController.loadMarker('data/patt5.patt', function(markerId) {
					var markerRoot = arController.createThreeMarker(markerId, 3);
					markerRoot.add(torus);
					arScene.scene.add(markerRoot);
					console.log("markerID? "+markerId);
				});*/
			}

			function markerRecord(id, pos, vertex, timestamp, area) {
				var retval = [];
				retval.id = id;
				retval.pos = pos.slice();
				retval.vertex = vertex.slice();
				retval.timestamp = timestamp;
				retval.area = area;
				return retval;
			}

			function retireOld(history) {
				var stopFlag = false;
				while (history.length > 0 && !stopFlag) {
					var elapsed = Date.now() - history[0].timestamp;
					if (elapsed > 2000) {
						history.shift();
					} else {
						stopFlag = true;
					}
				}
			}

			function retireOld2(avgPos) {
				//console.log(Object.keys(avgPos).length);
				Object.keys(avgPos).forEach(function(key) {
			        var apos = avgPos[key];

			        if (apos == undefined)
			        	return;

			        var elapsed = Date.now() - apos.timestamp;

			        if (elapsed > 2000) {
						avgPos[key] = undefined;
					} else {
						stopFlag = true;
					}
			    });
			}

			function lerp(a, b, f)
			{
			    return a + f * (b - a);
			}

			function printAvgPos() {

				/*for (apos in avgPos) {
        			ctx.beginPath();
					ctx.arc(apos[0], apos[1], 8, 0, Math.PI * 2);
					ctx.fillStyle = "#00ff00";
					ctx.fill();
					ctx.fillText(id,apos[0],apos[1])
				}*/

				Object.keys(avgPos).forEach(function(key) {
			        var apos = avgPos[key];
			        if (apos == undefined)
			        	return;
			        ctx.font = "25px Arial";
			        ctx.beginPath();
					ctx.arc(apos[0], apos[1], 8, 0, Math.PI * 2);
					ctx.fillStyle = "#00ff00";
					ctx.fill();
					ctx.fillText(key,apos[0],apos[1]);
			    });
        		/*
				avgPos.forEach(function(apos) {
					//ctx.strokeStyle = 'green';
					ctx.beginPath();
					ctx.arc(apos[0], apos[1], 8, 0, Math.PI * 2);
					ctx.fillStyle = "#00ff00";
					ctx.fill();
					ctx.fillText(id,apos[0],apos[1])
				});*/
			}

			function toUTF16(codePoint) {
			    var TEN_BITS = parseInt('1111111111', 2);
			    function u(codeUnit) {
			        return '\\u'+codeUnit.toString(16).toUpperCase();
			    }

			    if (codePoint <= 0xFFFF) {
			        return u(codePoint);
			    }
			    codePoint -= 0x10000;

			    // Shift right to get to most significant 10 bits
			    var leadSurrogate = 0xD800 + (codePoint >> 10);

			    // Mask to get least significant 10 bits
			    var tailSurrogate = 0xDC00 + (codePoint & TEN_BITS);

			    return u(leadSurrogate) + u(tailSurrogate);
			}

			function mappingFunction() {

				var validCombi = [];
				var validCombiAlt = [];

				var yunmu = [
					"ai", "an", "ang", "ao", "a", 
					"e", "ei", "en", "eng", "er", 
					"i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", 
					"o", "ong", "ou", 
					"u", "ua", "uai", "uan", "uang", "ue", "ui", "un", "uo", 
					"v", "ve",
					"g"
				];

				var shengmu = [
					"", "b", "c", "ch", "d", "f", "g", "h", "j", "k", "l", "m", 
					"n", "p", "q", "r", "s", "sh", "t", "w", "x", "y", "z", "zh"
				];


				validCombi["n"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "g", "ian", "iang", "iao", "ie", "in", "ing", "iu", "ong", "ou", "u", "uan", "un", "uo", "v", "ve"];
				validCombi["l"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "eng", "i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iu", "ong", "ou", "u", "uan","un", "uo", "v", "ve"];
				validCombi["d"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ia", "ian", "iao", "ie", "ing", "iu", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["g"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["h"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["sh"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["t"] = ["ai", "an", "ang", "ao", "a", "e", "eng", "i", "ian", "iao", "ie", "ing", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["zh"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "ua", "uai", "uang", "ui", "un", "uo"];
				validCombi["m"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "iu", "o", "ou", "u"];
				validCombi["k"] = ["ai", "an", "ang", "ao", "a", "e", "en", "eng", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["ch"] = ["ai", "an", "ang", "ao", "a", "e", "eng", "i", "ong", "ou", "u", "ua", "uai", "uan", "uang", "ui", "un", "uo"];
				validCombi["p"] = ["ai", "an", "ang", "ao", "a", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "o", "ou", "u"];
				validCombi["z"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["c"] = ["ai", "an", "ang", "ao", "a", "e", "ei", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["b"] = ["ai", "an", "ang", "ao", "a", "ei", "en", "eng", "i", "ian", "iao", "ie", "in", "ing", "o", "u"];
				validCombi["s"] = ["ai", "an", "ang", "ao", "a", "e", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi["q"] = ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iang", "iong", "iu", "u", "uan", "ue", "un"];
				validCombi["y"] = ["an", "ang", "ao", "a", "e", "i", "in", "ing", "o", "ong", "ou", "u", "uan", "ue", "un"];
				validCombi["j"] = ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", "u", "uan", "ue", "un"];
				validCombi["x"] = ["i", "ia", "ian", "iang", "iao", "ie", "in", "ing", "iong", "iu", "u", "uan", "ue", "un"];
				validCombi["r"] = ["an", "ang", "ao", "e", "en", "eng", "i", "ong", "ou", "u", "uan", "ui", "un", "uo"];
				validCombi[""] = ["ao", "ai", "an", "ang", "ao", "e", "ei", "en", "eng", "er", "o", "ou"];
				validCombi["f"] = ["an", "ang", "a", "ei", "en", "eng", "o", "ou", "u"];
				validCombi["w"] = ["ai", "an", "ang", "a", "ei", "en", "eng", "o", "u"];

				// verify that there is no typo in validCombi

				var orderedValidCombi = [
					validCombi["n"], validCombi["l"], validCombi["d"], validCombi["g"], validCombi["h"],
					validCombi["sh"], validCombi["t"], validCombi["zh"], validCombi["m"], validCombi["k"],
					validCombi["ch"], validCombi["p"], validCombi["z"], validCombi["c"], 
					validCombi["b"],  validCombi["s"], validCombi["q"], validCombi["y"], 
					validCombi["j"], validCombi["x"], validCombi["r"], validCombi[""], validCombi["f"], validCombi["w"]
				];
				//console.log(orderedValidCombi.map(function(x) {return x.length;}));
				

				/// typo check 
				var result = true;
				shengmu.forEach(function(x) { 
					//console.log(validCombi[x]); 
					validCombi[x].forEach(function(y) {

						//result = result && yunmu.includes(y);
						//result = result && (yunmu.indexOf(y) != -1);

						if (typeof Array.prototype.includes === "function") { 
						    result = result && yunmu.includes(y);

						} else {
							result = result && (yunmu.indexOf(y) != -1);
						}
					}); 
				});
				// if true no typo in validCombi
				//console.log(result);


				//status.sort(function(a,b) {
				//    return a.val - b.val;
				//});

				yunmuCount = {};

				// count yunmu appearance in all the word combi

				yunmu.forEach(function(x) { 
					yunmuCount[x] = 0;
					shengmu.forEach(function(y) {
						if (validCombi[y].includes(x))
							yunmuCount[x]++;
					});
				});

				//console.log(yunmuCount);

				var sortedYunmu = yunmu.sort(function(a, b){ return yunmuCount[b] - yunmuCount[a]; });
				console.log(yunmuCount);
				console.log(sortedYunmu);
			}
			
			function tick (ctx) {
				arScene.process(obj3d);
				arScene.renderOn(renderer);
				requestAnimationFrame(function () { 
					tick(ctx); 
				});
				var markerNum = arController.getMarkerNum();
				ctx.clearRect(0,0,canvasWidth,canvasHeight);

				prevMarkerTracked = markerTracked;
				markerTracked = {};
				
				retireOld(history);
				retireOld2(avgPos);

				//console.log(arScene);

				for (var i = 0; i<markerNum; i++) {
					var markerInfo = arController.getMarker(i);
					var vertexA = markerInfo.vertex;
					var pos = markerInfo.pos;
					var nativeID = markerInfo.id;
					var id = -1;
					var color = "blue";
					var area = markerInfo.area;
					var newMarkerRecord = null;

					// pattern marker
					/*if (markerInfo.idPatt >= 0 || markerInfo.idMatrix < 0) {
						//markerTracked[markerInfo.idPatt] = markerInfo;
						id = markerInfo.idPatt;
					}

					// matrix marker
					else if (markerInfo.idMatrix >= 0 && markerInfo.idPatt < 0) {
						//markerTracked[markerInfo.idMatrix] = markerInfo;
						id = markerInfo.idMatrix;
					}*/

					if (markerInfo.id >= 0) {
						id = markerInfo.id;
						//console.log(markerInfo);
					}
					


					/*if (nativeID >= 0) {
						console.log(markerInfo);
						id = Math.max(nativeID, id);
					}*/


					if (markerInfo.area > 400) {
						//console.log("area " + markerInfo.area);
						//markerTracked[markerInfo.idMatrix] = markerInfo;
						newMarkerRecord = markerRecord(id, pos, vertexA, Date.now(), area);
						markerTracked[markerInfo.idMatrix] = newMarkerRecord;

						if (id != -1) {
							if (avgPos[id] == undefined) {
								avgPos[id] = pos.slice();
							} else {
								var newPos = pos.slice();
								var oldPos = avgPos[id];
								var newX = lerp(oldPos[0], newPos[0], 0.6);
								var newY = lerp(oldPos[1], newPos[1], 0.6);
								var lerpedPos = [newX, newY];
								lerpedPos.timestamp = Date.now();
								avgPos[id] = lerpedPos;
							}
							/*console.log(id);
							console.log(markerInfo.idMatrix);
							console.log(vertexA[0]);
							console.log(vertexA[1]);
							console.log(vertexA[2]);
							console.log(vertexA[3]);
							*/

							//console.log(avgVertex);
							//avgVertex[id] = vertexA.slice();
							avgVertex[id] = JSON.parse(JSON.stringify(vertexA));
							

							//console.log(avgVertex);
						}
					}


					if (id >= 0) {
						color = "#00ff00";
					} else {
						color = "#ff0000";
					}
					drawMarkerOutline(vertexA, pos, color, id);

					//if (id >= 0) {
					//	console.log(id + " " + pos );
						//console.log(markerTracked);
					//}
					if (newMarkerRecord != null)
						history.push(newMarkerRecord);

					// 34 A pos
					// 20 marker width
					//15/30 
					// 90 card width

					function largerDXpair(id) {
						var x1 = avgVertex[id][1][0];
						var x2 = avgVertex[id][2][0];
						var x3 = avgVertex[id][3][0];

						var dx1 = Math.abs(x2 - x1);
						var dx2 = Math.abs(x3 - x2);

						if (dx2 > dx1) return [2, 3];
						else return [1, 2];
					}

					function markerWidth(id) {
						var x1 = avgVertex[id][1][0];
						var x2 = avgVertex[id][2][0];
						var x3 = avgVertex[id][3][0];

						var dx1 = Math.abs(x2 - x1);
						var dx2 = Math.abs(x3 - x2);
						/*
						var y1 = avgVertex[id][1][1];
						var y2 = avgVertex[id][2][1];
						var y3 = avgVertex[id][3][1]; 
						var dy1 = Math.abs(y2 - y1);
						var dy2 = Math.abs(y3 - y2);
						//var dx_min = Math.min(dx1, dx2);
						//var dy_max = Math.max(dy1, dy2);
						//var dy_min = Math.min(dy1, dy2);
						//console.log(dx_max);
						*/
						var dx_max = Math.max(dx1, dx2);
						return dx_max;
					}

					function cloneTransform(src, dest) {
						//var newObj = new THREE.Object3D();
						var pos = src.getWorldPosition();
						var quat = src.getWorldQuaternion();
						//console.log(newObj.matrixAutoUpdate);
						//console.log(pos);

						var parent = src.parent;
						THREE.SceneUtils.detach(dest, dest.parent, scene);

						dest.position.set(pos.x, pos.y, pos.z);
						dest.quaternion.set(quat.x, quat.y, quat.z, quat.w);

						parent.add(dest);
						//console.log(newObj.position);
					}

					

					function screenSpaceCheck() {
						if (avgPos[62] != undefined && avgPos[63] != undefined) {// && avgPos[62] != undefined && avgPos[63] != undefined) {
							//console.log(avgVertex[61]);
							var mw = markerWidth(62);
							var cardWidth = mw / 20 * 90;
							var cardSixth = cardWidth / 6;
							var markerX = avgPos[63][0];

							// dependent on orientation
							var cardLeft = avgPos[62][0] - cardSixth;
							var cardproper = cardLeft + ((56/90) * cardWidth);
							var error = Math.abs(cardproper - markerX);

							//console.log(cardproper + " " + markerX + " " + error);
							//console.log(cardLeft + " " + cardWidth);

							/*if (error < 3) {
								//console.log("correct");
								ctx.fillStyle = 'green';
								ctx.font = "50px Arial";
								ctx.fillText("correct",320,100);
							}*/

							/* else {
								console.log("wrong");
								ctx.fillStyle = 'red';
								ctx.font = "50px Arial";
								ctx.fillText("wrong",320,100);
							}*/
							return (error < 3);
						}
					}

					// 3d solution

					/*if (true) {
						var scene = arScene.scene;
						var anchor = scene.children[2];
						var child2 = anchor.children[1];
						var child3 = anchor.children[2];

						var clone2 = anchor.children[4];
						var clone3 = anchor.children[5];
						
						var quaternion = child2.getWorldQuaternion();
						var euler = new THREE.Euler().setFromQuaternion( quaternion );

						var localQuat = child2.quaternion;
						var localEuler = new THREE.Euler().setFromQuaternion( localQuat );

						//console.log(child2.getWorldPosition());
						//console.log(child3.getWorldPosition());

						const rad2deg = (180 / Math.PI);
						var v3 = euler.toVector3();
						v3.multiplyScalar (rad2deg);
						var v4 = localEuler.toVector3();
						v4.multiplyScalar (rad2deg);

						var worldDir = child2.getWorldDirection().normalize();
						console.log(worldDir);

						cloneTransform(child2, clone2);
						cloneTransform(child3, clone3);

						var worldDir2 = clone2.getWorldDirection().normalize();
						console.log(worldDir2);

						testObj.rotation.x = testObj.rotation.x + 45;

						var worldDir3 = clone2.getWorldDirection().normalize();
						console.log(worldDir3);

					}*/

					function space3DCheck() {
						var scene = arScene.scene;
						var anchor = scene.children[2];
						var child2 = anchor.children[1];
						var child3 = anchor.children[2];

						var wp3 = child3.getWorldPosition();
						var child2InChild3Local = child2.worldToLocal(wp3);
						//console.log(child2InChild3Local.x);
						var targetX = ((56 - 15) / 20);
						//console.log(targetX);
						var error = Math.abs(child2InChild3Local.x  - targetX);
						//console.log(error);

						const thresh = 6/20;
						return (error <= thresh)
					}

					if (true) {

						//var check = screenSpaceCheck() || space3DCheck();
						
						/*if (check) {
							console.log("correct");
							ctx.fillStyle = 'green';
							ctx.font = "50px Arial";
							ctx.fillText("correct",320,100);
						} else {
							console.log("wrong");
							ctx.fillStyle = 'red';
							ctx.font = "50px Arial";
							ctx.fillText("wrong",320,100);
						}*/


						if (avgPos[63] != undefined && avgPos[62] != undefined) {
							var scene = arScene.scene;
							var anchor = scene.children[2];
							var child2 = anchor.children[1];
							var child3 = anchor.children[2];

							var worldRot = child2.getWorldRotation();
							const rad2deg = (180 / Math.PI);

							var rotVal = worldRot.toVector3().multiplyScalar(rad2deg).z;


							var notMarkerPos = new THREE.Vector2(avgPos[63][0], avgPos[63][1]);
							//console.log(avgPos[63][0], avgPos[63][1]);
							//console.log(notMarkerPos);
							var projection = 0;
							var dir = null;
							var v = null;
							var v1, v2, v3, v4;

							var v0raw = avgVertex[62][0];
							var v1raw = avgVertex[62][1];
							var v2raw = avgVertex[62][2];
							var v3raw = avgVertex[62][3];

							v0 = new THREE.Vector2(v0raw[0], v0raw[1]);
							v1 = new THREE.Vector2(v1raw[0], v1raw[1]);
							v2 = new THREE.Vector2(v2raw[0], v2raw[1]);
							v3 = new THREE.Vector2(v3raw[0], v3raw[1]);

/*
							console.log(62 + " " + "here");
							console.log(v0raw);
							console.log(v1raw);
							console.log(v2raw);
							console.log(v3raw);

							console.log(63 + " " + "here");
							console.log( avgVertex[63][0]);
							console.log( avgVertex[63][1]);
							console.log( avgVertex[63][2]);
							console.log( avgVertex[63][3]);
*/							

							// do not change the order of if else condition check,
							// (if rotVal > 90 not checked first, rotVal >=0 will need another && rotVal <= 90)
							if (rotVal > 90) { // tilt left
								// 0 1
								dir = v1.sub(v0).normalize();
								v = notMarkerPos.sub(v0);
								projection = v.dot(dir);
							} else if (rotVal >= 0) { // tilt right on hand
								// 1 2
								dir = v2.sub(v1).normalize();
								v = notMarkerPos.sub(v1);
								projection = v.dot(dir);
							} else if (rotVal < -90) {// tilt left upside down
								// 3 4
								dir = v0.sub(v3).normalize();
								v = notMarkerPos.sub(v3);
								projection = v.dot(dir);
							} else if (rotVal < 0) { // tilt right upside down
								// 2 3
								dir = v3.sub(v2).normalize();
								v = notMarkerPos.sub(v2);
								projection = v.dot(dir);
							}

							console.log(projection);
							//console.log(dir);
							//console.log(v);
							console.log("");
						}

						//console.log(rotVal);




						//largerDXpair(62)
						
					}

					/*

					if (avgPos[61] != undefined && avgPos[62] != undefined) {
						//console.log(avgPos[61]);
						//console.log(avgPos[62]);	
						var dx = avgPos[61][0] - avgPos[62][0];
						var dy = avgPos[61][1] - avgPos[62][1];
						cardLen = Math.sqrt(dx*dx + dy*dy);
						//console.log(cardLen);
					}

					if (avgPos[61] != undefined && avgPos[63] != undefined) {
						var dx = avgPos[61][0] - avgPos[63][0];
						ref1 = dx/cardLen+0.001;

						//console.log("ref 61 "+x);
					}

					if (avgPos[62] != undefined && avgPos[63] != undefined) {
						var dx = avgPos[62][0] - avgPos[63][0];
						ref2 = dx/cardLen+0.001;
						//console.log("ref 62 "+x);
					}

					// 61 stand in for 62 for ref2 calculation
					if (avgPos[61] != undefined && avgPos[62] == undefined && avgPos[63] != undefined) {
						var dx = avgPos[61][0] - avgPos[63][0];
						ref2 = (dx - cardLen)/cardLen+0.001;
					}

					// 62 stand in for 61 for ref1 calculation
					if (avgPos[62] != undefined && avgPos[61] == undefined && avgPos[63] != undefined) {
						var dx = avgPos[62][0] - avgPos[63][0];
						ref1 = (dx + cardLen)/cardLen+0.001;
					}





					if (avgPos[60] != undefined && avgPos[62] != undefined) {
						//console.log(avgPos[61]);
						//console.log(avgPos[62]);	
						var dx = avgPos[60][0] - avgPos[62][0];
						var dy = avgPos[60][1] - avgPos[62][1];
						cardLen = Math.sqrt(dx*dx + dy*dy);
						//console.log(cardLen);
					}

					if (avgPos[60] != undefined && avgPos[63] != undefined) {
						var dx = avgPos[60][0] - avgPos[63][0];
						ref1 = dx/cardLen+0.001;

						//console.log("ref 61 "+x);
					}

					if (avgPos[62] != undefined && avgPos[63] != undefined) {
						var dx = avgPos[62][0] - avgPos[63][0];
						ref2 = dx/cardLen+0.001;
						//console.log("ref 62 "+x);
					}

					// 61 stand in for 62 for ref2 calculation
					if (avgPos[60] != undefined && avgPos[62] == undefined && avgPos[63] != undefined) {
						var dx = avgPos[60][0] - avgPos[63][0];
						ref2 = (dx - cardLen)/cardLen+0.001;
					}

					// 62 stand in for 61 for ref1 calculation
					if (avgPos[62] != undefined && avgPos[60] == undefined && avgPos[63] != undefined) {
						var dx = avgPos[62][0] - avgPos[63][0];
						ref1 = (dx + cardLen)/cardLen+0.001;
					}
					*/
				}
				
				screenTextDisplay(markerTracked);
				//consoleDebug(markerTracked);
				//console.log(markerTracked);
				//console.log(avgPos);
				printAvgPos();
				
				function consoleDebug(markerTracked) {
					var keyList = Object.keys(markerTracked);
					if (keyList.length > 0)
						//console.log(keyList);
						console.log(keyList.length);
				}
				
				function drawMarkerOutline(vertex, pos, color, id) {
					//if (id==-1) id = 99;
					//if (id2==-1) id2 = 99;
					ctx.strokeStyle = 'red';
					ctx.beginPath();
					ctx.moveTo(vertex[0][0], vertex[0][1]);
					ctx.lineTo(vertex[1][0], vertex[1][1]);
					ctx.stroke();

					ctx.strokeStyle = 'blue';
					ctx.beginPath();
					ctx.lineTo(vertex[1][0], vertex[1][1]);
					ctx.lineTo(vertex[2][0], vertex[2][1]);
					ctx.stroke();
					ctx.strokeStyle = 'green';

					ctx.beginPath();
					ctx.moveTo(vertex[2][0], vertex[2][1]);
					ctx.lineTo(vertex[3][0], vertex[3][1]);
					ctx.stroke();

					ctx.strokeStyle = 'yellow';
					ctx.beginPath();
					ctx.moveTo(vertex[3][0], vertex[3][1]);
					ctx.lineTo(vertex[0][0], vertex[0][1]);
					ctx.stroke();

					ctx.beginPath();
					ctx.arc(pos[0], pos[1], 8, 0, Math.PI * 2);
					ctx.fillStyle = color;
					ctx.fill();

					ctx.font = "25px Arial";
					ctx.fillText(id,pos[0],pos[1]);
				}
				
				function screenTextDisplay(markerTracked) {
					
					function arrContains(ht, obj) {
						//return (ht.indexOf(obj) != -1);
						return (ht[obj] != undefined);
					}
					
					function roundDecPlace(num, dec_place) {
						var modifier = dec_place * 10;
						return Math.round(num * modifier) / modifier;
					}
					
					ctx.font = "25px Arial";
					
					/*
					// combination detection
					if (arrContains(markerTracked, 0) && 
						arrContains(markerTracked, 1) &&
						arrContains(markerTracked, 2)) 
					{
						ctx.fillText("biang2",5,30);
					}*/
					
					// print position on screen for marker 0 and 2 (corresponds to notation marker and tail marker)
					/*
					if (avgPos[61] != null) {
						ctx.fillText(
						roundDecPlace(avgPos[61][0], 2) + "|" + 
						roundDecPlace(avgPos[61][1], 2)
						,5,65);
					}
					
					if (avgPos[62] != null) {
						ctx.fillText(
						roundDecPlace(avgPos[62][0], 2) + "|" + 
						roundDecPlace(avgPos[62][1], 2)
						,5,95);
					}

					if (avgPos[63] != null) {
						ctx.fillText(
						roundDecPlace(avgPos[63][0], 2) + "|" + 
						roundDecPlace(avgPos[63][1], 2)
						,5,125);
					}
					*/
					
					/*
					ctx.fillStyle = "green";
					ctx.fillText(roundDecPlace(cardLen, 2),5,160);
					ctx.fillText(roundDecPlace(ref1, 2),5,190);
					ctx.fillText(roundDecPlace(ref2, 2),5,220);
					*/
					
/*
					if (ref1 > 0)
						ctx.fillText("valid",5,250);
					else 
						ctx.fillText("invalid",5,250);
*/

			

			//console.log(sortedYunmu);


			// marker mapping
			// [0 - 3] first 3 used for notation
			// 
			
			
					var markerDetectedCount = 0;
					if (avgPos[60] != undefined ) markerDetectedCount++;
					if (avgPos[61] != undefined ) markerDetectedCount++;
					if (avgPos[62] != undefined ) markerDetectedCount++;
					if (avgPos[63] != undefined ) markerDetectedCount++;

					if (markerDetectedCount >= 3) {
						ctx.font = "60px Hypy";
						ctx.fillStyle = "#ff0000";

						var mytext = "ch"+ "\u00ED" + "ang";
						//var mytext2 = "chi"+ "\u00E1" + "ng";
						var mytext3a = "\u02C9";
						var mytext3b = "\u02CA";
						var mytext3 = "chiang";

						var mytext4 = "j"+ "\u00ED" + "ang";
						//var mytext5 = "ji"+ "\u00E1" + "ng";
						var mytext6a = "\u02C9";
						var mytext6b = "\u02CA";
						var mytext6 = "jiang";

						//ctx.fillText("chiang",216,100);
						if (ref1 > 0) {
							if (avgPos[61] != undefined) {
								if (ref1 <= 0.45 && ref2 <= -0.55) {
									ctx.fillText(mytext,215,100);
								}
								else if (ref1 < 0.65 && ref2 < -0.35) {
									ctx.fillStyle = "#00ff00";
									ctx.fillText(mytext3,215,100);
									ctx.fillText(mytext3b,300,100);
								}
								else if (ref1 < 0.875 && ref2 < -0.125) {
									ctx.fillText("chiang",215,100);
								}
								else {
									ctx.fillText("chiang",215,100);
								}
							}
							if (avgPos[60] != undefined) {
								if (ref1 <= 0.45 && ref2 <= -0.55) {
									ctx.fillText(mytext4,215,100);
								}
								else if (ref1 < 0.65 && ref2 < -0.35) {
									ctx.fillStyle = "#00ff00";
									ctx.fillText(mytext6,215,100);
									ctx.fillText(mytext6b,250,100);
								}
								else if (ref1 < 0.875 && ref2 < -0.125) {
									ctx.fillText("jiang",215,100);
								}
								else {
									ctx.fillText("jiang",215,100);
								}
							}
						}
					}
					// i 0.35 -0.65
					// a 0.55 -0.45
					// n 0.75 -0.25
					// g 1 0

				}
			}
		}
	}); // end of get getUserMediaThreeScene

	delete window.ARThreeOnLoad;
};

if (window.ARController && ARController.getUserMediaThreeScene) {
	ARThreeOnLoad();
}
</script>

</body>
</html>